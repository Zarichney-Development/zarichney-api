name: 'Check Changed Paths'
description: 'Intelligent path filtering to determine what components changed'
author: 'Zarichney Development'

inputs:
  base-ref:
    description: 'Base branch reference for comparison'
    required: false
    default: 'origin/develop'

outputs:
  backend-changed:
    description: 'Whether backend code changed'
    value: ${{ steps.categorize.outputs.backend-changed }}
  frontend-changed:
    description: 'Whether frontend code changed'
    value: ${{ steps.categorize.outputs.frontend-changed }}
  pipeline-changed:
    description: 'Whether pipeline scripts changed'
    value: ${{ steps.categorize.outputs.pipeline-changed }}
  docs-only:
    description: 'Whether only documentation changed'
    value: ${{ steps.categorize.outputs.docs-only }}
  tests-changed:
    description: 'Whether test files changed'
    value: ${{ steps.categorize.outputs.tests-changed }}
  changed-files:
    description: 'List of changed files'
    value: ${{ steps.categorize.outputs.changed-files }}

runs:
  using: 'composite'
  steps:
    - name: Resolve base reference
      id: resolve-base-ref
      shell: bash
      run: |
        BASE_REF="${{ inputs.base-ref }}"
        echo "Input base reference: $BASE_REF"
        
        # Handle different reference types
        if [[ "$BASE_REF" == "HEAD~1" ]]; then
          # For HEAD~1, check if it exists
          if git rev-parse --verify HEAD~1 >/dev/null 2>&1; then
            echo "Using HEAD~1 for comparison"
            echo "base_ref_resolved=HEAD~1" >> $GITHUB_OUTPUT
          else
            echo "HEAD~1 doesn't exist (possibly first commit), treating as all files changed"
            # Use an empty tree to compare against (will show all files as changed)
            echo "base_ref_resolved=4b825dc642cb6eb9a060e54bf8d69288fbee4904" >> $GITHUB_OUTPUT
          fi
        elif [[ "$BASE_REF" == origin/* ]]; then
          # For origin/ references, fetch the remote branch
          LOCAL_BASE_REF="${BASE_REF#origin/}"
          echo "Fetching remote branch: $LOCAL_BASE_REF"
          
          # Fetch the remote branch
          if git fetch origin "$LOCAL_BASE_REF" 2>/dev/null; then
            echo "Successfully fetched $LOCAL_BASE_REF"
            echo "base_ref_resolved=$BASE_REF" >> $GITHUB_OUTPUT
          else
            echo "Failed to fetch $LOCAL_BASE_REF, falling back to HEAD~1"
            echo "base_ref_resolved=HEAD~1" >> $GITHUB_OUTPUT
          fi
        else
          # For local references, check if they exist
          if git show-ref --verify --quiet "refs/heads/$BASE_REF" 2>/dev/null; then
            echo "Local reference found: $BASE_REF"
            echo "base_ref_resolved=$BASE_REF" >> $GITHUB_OUTPUT
          else
            echo "Reference not found, falling back to HEAD~1"
            echo "base_ref_resolved=HEAD~1" >> $GITHUB_OUTPUT
          fi
        fi

    - name: Check for path changes
      id: check-changes
      uses: dorny/paths-filter@v2
      with:
        base: ${{ steps.resolve-base-ref.outputs.base_ref_resolved }}
        list-files: none
        initial-fetch-depth: 0
        filters: |
          backend:
            - 'Code/Zarichney.Server/**'
            - '*.sln'
            - '**/*.csproj'
          frontend:
            - 'Code/Zarichney.Website/**'
            - 'Code/Zarichney.Website/package*.json'
          pipeline:
            - 'Scripts/Pipeline/**'
            - '.github/workflows/**'
            - '.github/actions/**'
          tests:
            - '**/*Tests/**'
            - '**/*.Tests/**'
            - '**/*Test.cs'
            - '**/*Tests.cs'
          docs:
            - '**/*.md'
            - 'Docs/**'
            - '**/*.txt'
          config:
            - '.editorconfig'
            - '.gitignore'
            - 'Scripts/*.sh'
            - 'Scripts/*.ps1'

    - name: Determine change categories
      id: categorize
      shell: bash
      run: |
        echo "Categorizing changes..."
        
        # Check if only documentation changed
        if [ "${{ steps.check-changes.outputs.docs }}" = "true" ] && \
           [ "${{ steps.check-changes.outputs.backend }}" = "false" ] && \
           [ "${{ steps.check-changes.outputs.frontend }}" = "false" ] && \
           [ "${{ steps.check-changes.outputs.pipeline }}" = "false" ] && \
           [ "${{ steps.check-changes.outputs.tests }}" = "false" ]; then
          echo "docs-only=true" >> $GITHUB_OUTPUT
          echo "ğŸ“š Only documentation files changed"
        else
          echo "docs-only=false" >> $GITHUB_OUTPUT
        fi
        
        # Pass through the individual checks
        echo "backend-changed=${{ steps.check-changes.outputs.backend }}" >> $GITHUB_OUTPUT
        echo "frontend-changed=${{ steps.check-changes.outputs.frontend }}" >> $GITHUB_OUTPUT
        echo "pipeline-changed=${{ steps.check-changes.outputs.pipeline }}" >> $GITHUB_OUTPUT
        echo "tests-changed=${{ steps.check-changes.outputs.tests }}" >> $GITHUB_OUTPUT
        
        # Create summary of changes
        CHANGES_SUMMARY=""
        if [ "${{ steps.check-changes.outputs.backend }}" = "true" ]; then
          CHANGES_SUMMARY="$CHANGES_SUMMARY backend"
        fi
        if [ "${{ steps.check-changes.outputs.frontend }}" = "true" ]; then
          CHANGES_SUMMARY="$CHANGES_SUMMARY frontend"
        fi
        if [ "${{ steps.check-changes.outputs.pipeline }}" = "true" ]; then
          CHANGES_SUMMARY="$CHANGES_SUMMARY pipeline"
        fi
        if [ "${{ steps.check-changes.outputs.tests }}" = "true" ]; then
          CHANGES_SUMMARY="$CHANGES_SUMMARY tests"
        fi
        if [ "${{ steps.check-changes.outputs.docs }}" = "true" ]; then
          CHANGES_SUMMARY="$CHANGES_SUMMARY docs"
        fi
        if [ "${{ steps.check-changes.outputs.config }}" = "true" ]; then
          CHANGES_SUMMARY="$CHANGES_SUMMARY config"
        fi
        
        echo "changed-files=$CHANGES_SUMMARY" >> $GITHUB_OUTPUT
        echo "ğŸ” Changed components:$CHANGES_SUMMARY"