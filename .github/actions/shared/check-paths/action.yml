name: 'Check Changed Paths'
description: 'Intelligent path filtering to determine what components changed'
author: 'Zarichney Development'

inputs:
  base-ref:
    description: 'Base branch reference for comparison'
    required: false
    default: 'origin/develop'

outputs:
  backend-changed:
    description: 'Whether backend code changed'
    value: ${{ steps.categorize.outputs.backend-changed }}
  frontend-changed:
    description: 'Whether frontend code changed'
    value: ${{ steps.categorize.outputs.frontend-changed }}
  pipeline-changed:
    description: 'Whether pipeline scripts changed'
    value: ${{ steps.categorize.outputs.pipeline-changed }}
  docs-only:
    description: 'Whether only documentation changed'
    value: ${{ steps.categorize.outputs.docs-only }}
  tests-changed:
    description: 'Whether test files changed'
    value: ${{ steps.categorize.outputs.tests-changed }}
  changed-files:
    description: 'List of changed files'
    value: ${{ steps.categorize.outputs.changed-files }}

runs:
  using: 'composite'
  steps:
    - name: Resolve base reference
      id: resolve-base-ref
      shell: bash
      run: |
        BASE_REF="${{ inputs.base-ref }}"
        echo "Input base reference: $BASE_REF"
        
        # Handle different reference types
        if [[ "$BASE_REF" == "HEAD~1" ]]; then
          # For HEAD~1, check if it exists
          if git rev-parse --verify HEAD~1 >/dev/null 2>&1; then
            echo "Using HEAD~1 for comparison"
            echo "base_ref_resolved=HEAD~1" >> $GITHUB_OUTPUT
          else
            echo "HEAD~1 doesn't exist (possibly first commit), treating as all files changed"
            # Use an empty tree to compare against (will show all files as changed)
            echo "base_ref_resolved=4b825dc642cb6eb9a060e54bf8d69288fbee4904" >> $GITHUB_OUTPUT
          fi
        elif [[ "$BASE_REF" == origin/* ]]; then
          # For origin/ references, fetch the remote branch
          LOCAL_BASE_REF="${BASE_REF#origin/}"
          echo "Fetching remote branch: $LOCAL_BASE_REF"
          
          # Fetch the remote branch
          if git fetch origin "$LOCAL_BASE_REF" 2>/dev/null; then
            echo "Successfully fetched $LOCAL_BASE_REF"
            echo "base_ref_resolved=$BASE_REF" >> $GITHUB_OUTPUT
          else
            echo "Failed to fetch $LOCAL_BASE_REF, falling back to HEAD~1"
            echo "base_ref_resolved=HEAD~1" >> $GITHUB_OUTPUT
          fi
        else
          # For local references, check if they exist
          if git show-ref --verify --quiet "refs/heads/$BASE_REF" 2>/dev/null; then
            echo "Local reference found: $BASE_REF"
            echo "base_ref_resolved=$BASE_REF" >> $GITHUB_OUTPUT
          else
            echo "Reference not found, falling back to HEAD~1"
            echo "base_ref_resolved=HEAD~1" >> $GITHUB_OUTPUT
          fi
        fi

    - name: Check for path changes
      id: check-changes
      shell: bash
      run: |
        BASE_REF="${{ steps.resolve-base-ref.outputs.base_ref_resolved }}"
        echo "Checking changes against base: $BASE_REF"
        
        # Get the list of changed files
        if [[ "$BASE_REF" == "4b825dc642cb6eb9a060e54bf8d69288fbee4904" ]]; then
          # Empty tree - all files are changed
          CHANGED_FILES=$(git ls-tree -r --name-only HEAD)
        else
          # Normal diff
          CHANGED_FILES=$(git diff --name-only "$BASE_REF" HEAD 2>/dev/null || git ls-tree -r --name-only HEAD)
        fi
        
        echo "Changed files:"
        echo "$CHANGED_FILES"
        
        # Check each category
        BACKEND_CHANGED=false
        FRONTEND_CHANGED=false
        PIPELINE_CHANGED=false
        TESTS_CHANGED=false
        DOCS_CHANGED=false
        CONFIG_CHANGED=false
        
        while IFS= read -r file; do
          [[ -z "$file" ]] && continue
          echo "Checking file: $file"
          
          # Backend patterns
          if [[ "$file" == Code/Zarichney.Server/* ]] || [[ "$file" == *.sln ]] || [[ "$file" == */*.csproj ]]; then
            BACKEND_CHANGED=true
          fi
          
          # Frontend patterns  
          if [[ "$file" == Code/Zarichney.Website/* ]]; then
            FRONTEND_CHANGED=true
          fi
          
          # Pipeline patterns
          if [[ "$file" == .github/scripts/* ]] || [[ "$file" == .github/workflows/* ]] || [[ "$file" == .github/actions/* ]]; then
            PIPELINE_CHANGED=true
          fi
          
          # Test patterns
          if [[ "$file" == *Tests/* ]] || [[ "$file" == *.Tests/* ]] || [[ "$file" == *Test.cs ]] || [[ "$file" == *Tests.cs ]]; then
            TESTS_CHANGED=true
          fi
          
          # Documentation patterns
          if [[ "$file" == *.md ]] || [[ "$file" == Docs/* ]] || [[ "$file" == *.txt ]]; then
            DOCS_CHANGED=true
          fi
          
          # Config patterns
          if [[ "$file" == .editorconfig ]] || [[ "$file" == .gitignore ]] || [[ "$file" == .github/scripts/*.sh ]] || [[ "$file" == .github/scripts/*.ps1 ]]; then
            CONFIG_CHANGED=true
          fi
        done <<< "$CHANGED_FILES"
        
        # Output results
        echo "backend=$BACKEND_CHANGED" >> $GITHUB_OUTPUT
        echo "frontend=$FRONTEND_CHANGED" >> $GITHUB_OUTPUT
        echo "pipeline=$PIPELINE_CHANGED" >> $GITHUB_OUTPUT
        echo "tests=$TESTS_CHANGED" >> $GITHUB_OUTPUT
        echo "docs=$DOCS_CHANGED" >> $GITHUB_OUTPUT
        echo "config=$CONFIG_CHANGED" >> $GITHUB_OUTPUT
        
        echo "Results: backend=$BACKEND_CHANGED, frontend=$FRONTEND_CHANGED, pipeline=$PIPELINE_CHANGED, tests=$TESTS_CHANGED, docs=$DOCS_CHANGED, config=$CONFIG_CHANGED"

    - name: Determine change categories
      id: categorize
      shell: bash
      run: |
        echo "Categorizing changes..."
        
        # Check if only documentation changed
        if [ "${{ steps.check-changes.outputs.docs }}" = "true" ] && \
           [ "${{ steps.check-changes.outputs.backend }}" = "false" ] && \
           [ "${{ steps.check-changes.outputs.frontend }}" = "false" ] && \
           [ "${{ steps.check-changes.outputs.pipeline }}" = "false" ] && \
           [ "${{ steps.check-changes.outputs.tests }}" = "false" ]; then
          echo "docs-only=true" >> $GITHUB_OUTPUT
          echo "üìö Only documentation files changed"
        else
          echo "docs-only=false" >> $GITHUB_OUTPUT
        fi
        
        # Pass through the individual checks
        echo "backend-changed=${{ steps.check-changes.outputs.backend }}" >> $GITHUB_OUTPUT
        echo "frontend-changed=${{ steps.check-changes.outputs.frontend }}" >> $GITHUB_OUTPUT
        echo "pipeline-changed=${{ steps.check-changes.outputs.pipeline }}" >> $GITHUB_OUTPUT
        echo "tests-changed=${{ steps.check-changes.outputs.tests }}" >> $GITHUB_OUTPUT
        
        # Create summary of changes
        CHANGES_SUMMARY=""
        if [ "${{ steps.check-changes.outputs.backend }}" = "true" ]; then
          CHANGES_SUMMARY="$CHANGES_SUMMARY backend"
        fi
        if [ "${{ steps.check-changes.outputs.frontend }}" = "true" ]; then
          CHANGES_SUMMARY="$CHANGES_SUMMARY frontend"
        fi
        if [ "${{ steps.check-changes.outputs.pipeline }}" = "true" ]; then
          CHANGES_SUMMARY="$CHANGES_SUMMARY pipeline"
        fi
        if [ "${{ steps.check-changes.outputs.tests }}" = "true" ]; then
          CHANGES_SUMMARY="$CHANGES_SUMMARY tests"
        fi
        if [ "${{ steps.check-changes.outputs.docs }}" = "true" ]; then
          CHANGES_SUMMARY="$CHANGES_SUMMARY docs"
        fi
        if [ "${{ steps.check-changes.outputs.config }}" = "true" ]; then
          CHANGES_SUMMARY="$CHANGES_SUMMARY config"
        fi
        
        echo "changed-files=$CHANGES_SUMMARY" >> $GITHUB_OUTPUT
        echo "üîç Changed components:$CHANGES_SUMMARY"