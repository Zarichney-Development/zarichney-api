name: "Coverage Epic Automation"

# Coverage Epic Automation Workflow
# Executes via workflow_dispatch to generate test coverage improvements
# Triggered by Coverage Epic Scheduler every 6 hours or manually
# Each execution creates autonomous AI agent tasks contributing to Epic #94
# Target: 90% backend test coverage by January 2026

on:
  # Explicitly prevent push events to avoid unintended executions
  # This workflow should only run on manual dispatch or external scheduler triggers
  workflow_dispatch:
    inputs:
      skip_epic_update:
        description: 'Skip epic branch update from develop'
        required: false
        default: false
        type: boolean
      skip_ai_execution:
        description: 'Skip AI agent execution (for infrastructure testing only)'
        required: false
        default: false
        type: boolean
      target_area:
        description: 'Optional target area for focused coverage (e.g., "Services", "Controllers")'
        required: false
        default: ''
        type: string
      scheduled_trigger:
        description: 'Indicates if this was triggered by the scheduler'
        required: false
        default: 'false'
        type: string
      trigger_source:
        description: 'Source of the trigger'
        required: false
        default: 'manual'
        type: string
      trigger_reason:
        description: 'Reason for the trigger'
        required: false
        default: 'Manual execution'
        type: string

# Prevent multiple concurrent executions to avoid agent conflicts
concurrency:
  group: coverage-epic-automation
  cancel-in-progress: false

env:
  DOTNET_VERSION: '8.0.x'
  EPIC_BRANCH: 'epic/testing-coverage-to-90'
  EPIC_ISSUE_ID: '94'

permissions:
  id-token: write
  contents: write
  actions: read
  pull-requests: write
  issues: write

jobs:
  coverage-epic-agent:
    name: "Coverage Epic AI Agent"
    runs-on: ubuntu-latest

    # Only run on main repository (not forks)
    if: github.repository == 'Zarichney-Development/zarichney-api'

    steps:
      # ========================================
      # Environment Setup
      # ========================================

      - name: "Checkout Repository"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Need full history for branch management
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: "Setup Development Environment"
        uses: ./.github/actions/shared/setup-environment
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}
          setup-node: false
          cache-dependencies: true

      - name: "Configure Git for Automation"
        run: |
          git config --global user.name "Coverage Epic Bot"
          git config --global user.email "noreply@zarichney.dev"
          git config --global init.defaultBranch main

      # ========================================
      # Production-Ready Epic Branch Management with Comprehensive Safety Features
      # ========================================

      - name: "Prepare Epic Branch with Production-Ready Management"
        id: epic-branch
        run: |
          echo "üîÑ Production-ready epic branch management: $EPIC_BRANCH"
          echo "üìã Implementing comprehensive branch state validation, remote tracking, and safe conflict resolution"

          # ========================================
          # Phase 1: Develop Branch Validation & Sync
          # ========================================
          echo "üîç Phase 1: Comprehensive develop branch validation"

          # Fetch all remote data first for accurate state analysis
          git fetch --all --prune

          if ! git show-ref --verify --quiet refs/heads/develop; then
            echo "üì• Local develop branch missing, creating from origin"
            git checkout -b develop origin/develop
          else
            echo "‚úÖ Local develop branch exists, switching to it"
            git checkout develop || {
              echo "‚ùå CRITICAL: Failed to checkout develop branch"
              git status --porcelain
              exit 1
            }
          fi

          # Enhanced develop branch sync with safety checks
          echo "üîÑ Performing safe develop branch synchronization"
          DEVELOP_LOCAL_COMMIT=$(git rev-parse HEAD)
          DEVELOP_REMOTE_COMMIT=$(git rev-parse origin/develop)

          echo "üîç Develop branch commit analysis:"
          echo "   Local:  $DEVELOP_LOCAL_COMMIT"
          echo "   Remote: $DEVELOP_REMOTE_COMMIT"

          if [ "$DEVELOP_LOCAL_COMMIT" != "$DEVELOP_REMOTE_COMMIT" ]; then
            # Check if local has uncommitted changes
            if ! git diff --quiet || ! git diff --cached --quiet; then
              echo "‚ö†Ô∏è SAFETY CHECK: Uncommitted changes detected on develop"
              git status --porcelain
              echo "‚ùå Cannot sync develop with uncommitted changes - manual intervention required"
              exit 1
            fi

            echo "üîÑ Local develop out of sync with remote, performing safe sync"
            # Use reset --hard only if we're sure no uncommitted changes exist
            git reset --hard origin/develop
            echo "‚úÖ Develop branch synchronized with remote"
          else
            echo "‚úÖ Develop branch already in sync with remote"
          fi

          # ========================================
          # Phase 2: Epic Branch State Analysis & Smart Synchronization
          # ========================================
          echo "üîç Phase 2: Comprehensive epic branch state analysis"

          # Enhanced remote and local existence checks
          REMOTE_EPIC_EXISTS=$(git ls-remote --heads origin "$EPIC_BRANCH" | wc -l)
          LOCAL_EPIC_EXISTS=$(git show-ref --verify --quiet refs/heads/$EPIC_BRANCH && echo "1" || echo "0")

          echo "üìä Detailed branch state analysis:"
          echo "   Remote epic branch exists: $([[ $REMOTE_EPIC_EXISTS -gt 0 ]] && echo 'YES' || echo 'NO')"
          echo "   Local epic branch exists: $([[ $LOCAL_EPIC_EXISTS -eq 1 ]] && echo 'YES' || echo 'NO')"

          if [[ $REMOTE_EPIC_EXISTS -gt 0 ]]; then
            echo "üìù Remote epic branch found - performing intelligent synchronization"

            # Fetch specific epic branch data with error handling
            if ! git fetch origin $EPIC_BRANCH; then
              echo "‚ùå CRITICAL: Failed to fetch remote epic branch data"
              exit 1
            fi

            REMOTE_EPIC_COMMIT=$(git rev-parse origin/$EPIC_BRANCH)
            echo "üîç Remote epic branch commit: $REMOTE_EPIC_COMMIT"

            if [[ $LOCAL_EPIC_EXISTS -eq 1 ]]; then
              echo "üîÑ Both local and remote epic branches exist - performing sync analysis"
              LOCAL_EPIC_COMMIT=$(git rev-parse $EPIC_BRANCH)

              echo "üîç Epic branch commit comparison:"
              echo "   Local:  $LOCAL_EPIC_COMMIT"
              echo "   Remote: $REMOTE_EPIC_COMMIT"

              if [ "$LOCAL_EPIC_COMMIT" != "$REMOTE_EPIC_COMMIT" ]; then
                echo "‚ö†Ô∏è Epic branch divergence detected - implementing safe resolution strategy"

                # Comprehensive divergence analysis
                if git merge-base --is-ancestor $LOCAL_EPIC_COMMIT origin/$EPIC_BRANCH; then
                  echo "üì• SAFE: Local branch is behind remote - fast-forward updating"
                  git checkout $EPIC_BRANCH
                  git reset --hard origin/$EPIC_BRANCH
                  echo "‚úÖ Fast-forward update completed successfully"

                elif git merge-base --is-ancestor origin/$EPIC_BRANCH $LOCAL_EPIC_COMMIT; then
                  echo "üì§ LOCAL AHEAD: Local branch has new commits - validating push safety"
                  git checkout $EPIC_BRANCH

                  # Safe push with comprehensive error handling
                  if git push origin $EPIC_BRANCH; then
                    echo "‚úÖ Local commits pushed to remote successfully"
                  else
                    echo "‚ùå PUSH FAILED: Remote may have been updated during execution"
                    echo "üîÑ Re-fetching and attempting recovery"
                    git fetch origin $EPIC_BRANCH

                    # Check if we can still fast-forward
                    if git merge-base --is-ancestor HEAD origin/$EPIC_BRANCH; then
                      echo "‚úÖ Remote changes are compatible - pulling and retrying push"
                      git pull origin $EPIC_BRANCH
                      git push origin $EPIC_BRANCH
                    else
                      echo "‚ùå CRITICAL: Epic branch has diverged during execution - manual intervention required"
                      exit 1
                    fi
                  fi

                else
                  echo "‚ö†Ô∏è DIVERGED BRANCHES: True divergence detected - implementing recovery strategy"

                  # Create recovery branch to preserve local work
                  RECOVERY_BRANCH="epic-recovery-$(date +%s)"
                  echo "üõ°Ô∏è Creating recovery branch to preserve local work: $RECOVERY_BRANCH"

                  git checkout $EPIC_BRANCH
                  git checkout -b $RECOVERY_BRANCH

                  if git push origin $RECOVERY_BRANCH; then
                    echo "‚úÖ Recovery branch created successfully: $RECOVERY_BRANCH"
                  else
                    echo "‚ùå CRITICAL: Failed to create recovery branch - aborting operation"
                    exit 1
                  fi

                  # Reset local epic branch to match remote (safe because work is preserved)
                  echo "üîÑ Resetting local epic branch to match remote (work preserved in recovery branch)"
                  git checkout $EPIC_BRANCH
                  git reset --hard origin/$EPIC_BRANCH

                  echo "‚úÖ Epic branch reset completed"
                  echo "‚ö†Ô∏è IMPORTANT: Previous work preserved in branch: $RECOVERY_BRANCH"
                  echo "üìã Manual review and merge of recovery branch may be required"
                fi
              else
                echo "‚úÖ Local and remote epic branches are perfectly in sync"
                git checkout $EPIC_BRANCH
              fi
            else
              echo "üì• Creating local epic branch from remote"
              git checkout -b $EPIC_BRANCH origin/$EPIC_BRANCH
              echo "‚úÖ Local epic branch created from remote"
            fi

            # ========================================
            # Phase 3: Remote Tracking Setup (CRITICAL FIX)
            # ========================================
            echo "üîó Phase 3: Ensuring proper remote tracking configuration"

            # Verify current tracking status
            CURRENT_UPSTREAM=$(git for-each-ref --format='%(upstream:short)' refs/heads/$EPIC_BRANCH)
            echo "üîç Current tracking branch: ${CURRENT_UPSTREAM:-'NONE'}"

            if [ "$CURRENT_UPSTREAM" != "origin/$EPIC_BRANCH" ]; then
              echo "üîß Setting up proper remote tracking"
              git branch --set-upstream-to=origin/$EPIC_BRANCH $EPIC_BRANCH

              # Verify tracking was set correctly
              NEW_UPSTREAM=$(git for-each-ref --format='%(upstream:short)' refs/heads/$EPIC_BRANCH)
              if [ "$NEW_UPSTREAM" = "origin/$EPIC_BRANCH" ]; then
                echo "‚úÖ Remote tracking configured successfully: $NEW_UPSTREAM"
              else
                echo "‚ùå CRITICAL: Remote tracking setup failed"
                exit 1
              fi
            else
              echo "‚úÖ Remote tracking already configured correctly"
            fi

            # ========================================
            # Phase 4: Branch Health & Compatibility Validation
            # ========================================
            echo "üîç Phase 4: Epic branch health and compatibility validation"

            # Fetch main branch for compatibility checks
            git fetch origin main
            MAIN_COMMIT=$(git rev-parse origin/main)
            EPIC_COMMIT=$(git rev-parse $EPIC_BRANCH)

            echo "üîç Branch compatibility analysis:"
            echo "   Main commit:  $MAIN_COMMIT"
            echo "   Epic commit:  $EPIC_COMMIT"

            # Analyze relationship between epic branch and main
            if git merge-base --is-ancestor origin/main $EPIC_BRANCH; then
              COMMITS_AHEAD=$(git rev-list --count origin/main..$EPIC_BRANCH)
              echo "‚úÖ Epic branch is ahead of main by $COMMITS_AHEAD commits - safe for eventual merge"

            elif git merge-base --is-ancestor $EPIC_BRANCH origin/main; then
              COMMITS_BEHIND=$(git rev-list --count $EPIC_BRANCH..origin/main)
              echo "‚ö†Ô∏è Epic branch is behind main by $COMMITS_BEHIND commits - consider rebasing in future"

            else
              MERGE_BASE=$(git merge-base $EPIC_BRANCH origin/main)
              EPIC_UNIQUE=$(git rev-list --count $MERGE_BASE..$EPIC_BRANCH)
              MAIN_UNIQUE=$(git rev-list --count $MERGE_BASE..origin/main)
              echo "üìä Epic branch and main have diverged:"
              echo "   Epic unique commits: $EPIC_UNIQUE"
              echo "   Main unique commits: $MAIN_UNIQUE"
              echo "   Monitor for merge complexity in future"
            fi

            # ========================================
            # Phase 5: Safe Develop Integration (Enhanced)
            # ========================================
            if ! ${{ github.event.inputs.skip_epic_update || 'false' }}; then
              echo "üîÑ Phase 5: Safe develop integration with enhanced conflict resolution"

              EPIC_BASE=$(git merge-base $EPIC_BRANCH develop)
              DEVELOP_COMMIT=$(git rev-parse develop)

              echo "üîç Develop integration analysis:"
              echo "   Epic base:    $EPIC_BASE"
              echo "   Develop HEAD: $DEVELOP_COMMIT"

              if [ "$EPIC_BASE" = "$DEVELOP_COMMIT" ]; then
                echo "‚úÖ Epic branch already includes latest develop changes - no integration needed"
              else
                COMMITS_TO_INTEGRATE=$(git rev-list --count $EPIC_BASE..$DEVELOP_COMMIT)
                echo "üîÑ Integrating $COMMITS_TO_INTEGRATE commits from develop branch"

                # Pre-merge validation
                echo "üîç Pre-merge validation"
                if ! git diff --quiet || ! git diff --cached --quiet; then
                  echo "‚ùå SAFETY CHECK: Uncommitted changes detected before merge"
                  git status --porcelain
                  exit 1
                fi

                # Attempt merge with comprehensive error handling
                echo "üîÑ Attempting develop merge with conflict detection"
                if git merge develop --no-edit --no-commit --no-ff; then
                  # Check if merge actually introduced changes
                  if git diff --cached --quiet; then
                    echo "‚úÖ No changes to commit - branches were already compatible"
                    git merge --abort  # Clean up the merge state
                  else
                    # Commit the merge
                    git commit --no-edit -m "chore: integrate latest develop changes into epic branch"$'\n\n'"Automated integration of develop branch changes into epic branch."$'\n'"Commits integrated: $COMMITS_TO_INTEGRATE"$'\n'"Integration method: Safe merge with conflict detection"$'\n'"Validation: Pre-merge safety checks passed"$'\n\n'"Co-Authored-By: Coverage Epic Bot <noreply@zarichney.dev>"

                    echo "‚úÖ Epic branch updated successfully with develop changes"

                    # Safe push with enhanced error handling
                    echo "üì§ Pushing integrated changes to remote"
                    if git push origin $EPIC_BRANCH; then
                      echo "‚úÖ Integrated changes pushed successfully"
                    else
                      echo "‚ö†Ô∏è Push failed - implementing recovery protocol"

                      # Fetch latest remote state
                      git fetch origin $EPIC_BRANCH
                      REMOTE_UPDATED_COMMIT=$(git rev-parse origin/$EPIC_BRANCH)

                      if git merge-base --is-ancestor HEAD origin/$EPIC_BRANCH; then
                        echo "üì• Remote has newer changes - pulling and retrying"
                        git pull origin $EPIC_BRANCH --no-edit
                        git push origin $EPIC_BRANCH
                        echo "‚úÖ Push succeeded after pull"
                      else
                        echo "‚ùå CRITICAL: Remote epic branch has diverged during merge"
                        echo "üõ°Ô∏è Implementing emergency recovery protocol"

                        # Create emergency recovery branch
                        EMERGENCY_BRANCH="epic-emergency-$(date +%s)"
                        git checkout -b $EMERGENCY_BRANCH
                        git push origin $EMERGENCY_BRANCH

                        echo "üö® EMERGENCY: Changes saved to branch: $EMERGENCY_BRANCH"
                        echo "‚ùå Epic branch operation failed - manual intervention required"
                        exit 1
                      fi
                    fi
                  fi
                else
                  echo "‚ö†Ô∏è Merge conflicts detected - implementing enhanced conflict resolution"

                  # Abort the failed merge
                  git merge --abort

                  # Enhanced conflict resolution strategy
                  echo "üîç Analyzing conflict complexity"
                  CONFLICTED_FILES=$(git diff --name-only develop | wc -l)
                  echo "üìä Files that would be affected: $CONFLICTED_FILES"

                  if [ $CONFLICTED_FILES -gt 10 ]; then
                    echo "‚ö†Ô∏è HIGH COMPLEXITY: Many files would be affected - using safe reset strategy"
                  else
                    echo "‚ÑπÔ∏è MODERATE COMPLEXITY: Attempting resolution strategies"
                  fi

                  # Create comprehensive recovery branch with metadata
                  RECOVERY_BRANCH="epic-recovery-conflicts-$(date +%s)"
                  echo "üõ°Ô∏è Creating comprehensive recovery branch: $RECOVERY_BRANCH"

                  git checkout -b $RECOVERY_BRANCH

                  # Add recovery metadata
                  echo "Epic Branch Recovery Metadata" > recovery-metadata.txt
                  echo "============================" >> recovery-metadata.txt
                  echo "Recovery Branch: $RECOVERY_BRANCH" >> recovery-metadata.txt
                  echo "Original Epic Branch: $EPIC_BRANCH" >> recovery-metadata.txt
                  echo "Develop Branch: develop" >> recovery-metadata.txt
                  echo "Conflict Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> recovery-metadata.txt
                  echo "Files Affected: $CONFLICTED_FILES" >> recovery-metadata.txt
                  echo "Epic Commit: $(git rev-parse $EPIC_BRANCH)" >> recovery-metadata.txt
                  echo "Develop Commit: $(git rev-parse develop)" >> recovery-metadata.txt
                  echo "Merge Base: $EPIC_BASE" >> recovery-metadata.txt
                  echo "" >> recovery-metadata.txt
                  echo "Recovery Instructions:" >> recovery-metadata.txt
                  echo "1. Review conflicts between epic and develop branches" >> recovery-metadata.txt
                  echo "2. Manually resolve conflicts in a separate working branch" >> recovery-metadata.txt
                  echo "3. Once resolved, update the epic branch" >> recovery-metadata.txt
                  echo "4. Delete this recovery branch after successful resolution" >> recovery-metadata.txt

                  git add recovery-metadata.txt
                  git commit -m "recovery: preserve epic branch state before conflict resolution"$'\n\n'"This recovery branch preserves the exact state of the epic branch"$'\n'"before attempting to merge develop changes that resulted in conflicts."$'\n\n'"Original epic branch: $EPIC_BRANCH"$'\n'"Conflicted develop merge at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"$'\n'"Files affected: $CONFLICTED_FILES"$'\n'"Manual resolution required"$'\n\n'"Co-Authored-By: Coverage Epic Bot <noreply@zarichney.dev>"

                  if git push origin $RECOVERY_BRANCH; then
                    echo "‚úÖ Recovery branch created and pushed: $RECOVERY_BRANCH"
                  else
                    echo "‚ùå CRITICAL: Failed to create recovery branch"
                    exit 1
                  fi

                  # Reset epic branch to develop (safe because work is preserved)
                  echo "üîÑ Resetting epic branch to develop (work preserved in recovery branch)"
                  git checkout $EPIC_BRANCH
                  git reset --hard develop

                  # SAFE push (no --force-with-lease on conflicts)
                  echo "üì§ Pushing reset epic branch (safe reset to develop)"
                  if git push origin $EPIC_BRANCH; then
                    echo "‚úÖ Epic branch reset and pushed successfully"
                  else
                    echo "‚ö†Ô∏è Push failed after reset - this indicates remote was updated during operation"
                    echo "üîÑ Fetching latest remote state and retrying"

                    git fetch origin $EPIC_BRANCH
                    # Since we're resetting to develop, this should be safe
                    git reset --hard develop
                    git push --force-with-lease origin $EPIC_BRANCH
                    echo "‚úÖ Epic branch force-pushed after reset (safe operation)"
                  fi

                  echo "üîÑ Epic branch reset to develop completed"
                  echo "‚ö†Ô∏è IMPORTANT: Previous epic work preserved in recovery branch: $RECOVERY_BRANCH"
                  echo "üìã Manual conflict resolution required - see recovery-metadata.txt"
                fi
              fi
            else
              echo "‚è≠Ô∏è Skipping epic branch develop integration (manual override enabled)"
            fi

          else
            # ========================================
            # New Epic Branch Creation with Enhanced Setup
            # ========================================
            echo "üÜï Creating new epic branch from develop with enhanced setup"

            # Ensure we're on develop before creating epic branch
            git checkout develop

            # Create epic branch from current develop
            git checkout -b $EPIC_BRANCH

            # Set up remote tracking immediately with comprehensive error handling
            echo "üîó Setting up remote tracking for new epic branch"
            if git push -u origin $EPIC_BRANCH; then
              echo "‚úÖ New epic branch created and pushed with remote tracking"

              # Verify tracking was established
              TRACKING_BRANCH=$(git for-each-ref --format='%(upstream:short)' refs/heads/$EPIC_BRANCH)
              if [ "$TRACKING_BRANCH" = "origin/$EPIC_BRANCH" ]; then
                echo "‚úÖ Remote tracking verified: $TRACKING_BRANCH"
              else
                echo "‚ùå CRITICAL: Remote tracking not established correctly"
                exit 1
              fi
            else
              echo "‚ùå CRITICAL: Failed to create remote epic branch"
              echo "üîç Checking repository permissions and branch protection"
              git remote -v
              exit 1
            fi
          fi

          # ========================================
          # Phase 6: Final Validation & Comprehensive Status Reporting
          # ========================================
          echo "üìä Phase 6: Final validation and comprehensive status reporting"

          # Comprehensive final state validation
          FINAL_EPIC_COMMIT=$(git rev-parse HEAD)
          TRACKING_BRANCH=$(git for-each-ref --format='%(upstream:short)' refs/heads/$EPIC_BRANCH)
          CURRENT_BRANCH=$(git branch --show-current)
          UNCOMMITTED_CHANGES=$(git status --porcelain | wc -l)

          # Branch status analysis
          if [ "$TRACKING_BRANCH" = "origin/$EPIC_BRANCH" ]; then
            TRACKING_STATUS="‚úÖ CONFIGURED"
          else
            TRACKING_STATUS="‚ùå NOT CONFIGURED"
          fi

          # Remote sync status check
          git fetch origin $EPIC_BRANCH
          REMOTE_FINAL_COMMIT=$(git rev-parse origin/$EPIC_BRANCH)
          if [ "$FINAL_EPIC_COMMIT" = "$REMOTE_FINAL_COMMIT" ]; then
            SYNC_STATUS="‚úÖ IN SYNC"
          else
            SYNC_STATUS="‚ö†Ô∏è OUT OF SYNC"
          fi

          # Branch ahead/behind analysis
          if [ "$FINAL_EPIC_COMMIT" != "$REMOTE_FINAL_COMMIT" ]; then
            if git merge-base --is-ancestor $FINAL_EPIC_COMMIT origin/$EPIC_BRANCH; then
              AHEAD_BEHIND="üì• LOCAL BEHIND REMOTE"
            elif git merge-base --is-ancestor origin/$EPIC_BRANCH $FINAL_EPIC_COMMIT; then
              AHEAD_BEHIND="üì§ LOCAL AHEAD OF REMOTE"
            else
              AHEAD_BEHIND="‚ö†Ô∏è BRANCHES DIVERGED"
            fi
          else
            AHEAD_BEHIND="‚úÖ PERFECTLY SYNCED"
          fi

          echo ""
          echo "=========================================="
          echo "üéØ EPIC BRANCH MANAGEMENT SUCCESS REPORT"
          echo "=========================================="
          echo "üìÖ Completion Time: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "üåø Epic Branch: $EPIC_BRANCH"
          echo "üìç Current Branch: $CURRENT_BRANCH"
          echo "üéØ Current Commit: $FINAL_EPIC_COMMIT"
          echo "üîó Tracking Branch: ${TRACKING_BRANCH:-'NONE'} ($TRACKING_STATUS)"
          echo "üîÑ Sync Status: $SYNC_STATUS"
          echo "üìä Ahead/Behind: $AHEAD_BEHIND"
          echo "üìã Uncommitted Changes: $UNCOMMITTED_CHANGES"
          echo ""
          echo "üîç Remote Validation:"
          echo "   Remote Commit: $REMOTE_FINAL_COMMIT"
          echo "   Local Commit:  $FINAL_EPIC_COMMIT"
          echo "   Match Status: $([[ "$FINAL_EPIC_COMMIT" == "$REMOTE_FINAL_COMMIT" ]] && echo '‚úÖ MATCH' || echo '‚ö†Ô∏è DIFFER')"
          echo ""

          # Critical validation checks
          VALIDATION_PASSED=true

          if [ "$CURRENT_BRANCH" != "$EPIC_BRANCH" ]; then
            echo "‚ùå VALIDATION FAILED: Not on epic branch"
            VALIDATION_PASSED=false
          fi

          if [ "$TRACKING_BRANCH" != "origin/$EPIC_BRANCH" ]; then
            echo "‚ùå VALIDATION FAILED: Remote tracking not configured"
            VALIDATION_PASSED=false
          fi

          if [ $UNCOMMITTED_CHANGES -gt 0 ]; then
            echo "‚ùå VALIDATION FAILED: Uncommitted changes present"
            git status --porcelain
            VALIDATION_PASSED=false
          fi

          if [ "$VALIDATION_PASSED" = true ]; then
            echo "‚úÖ ALL VALIDATIONS PASSED - Epic branch ready for operations"
            echo "=========================================="

            # Set success outputs
            echo "epic_branch_ready=true" >> $GITHUB_OUTPUT
            echo "current_commit=$FINAL_EPIC_COMMIT" >> $GITHUB_OUTPUT
            echo "tracking_branch=$TRACKING_BRANCH" >> $GITHUB_OUTPUT
            echo "epic_branch_name=$EPIC_BRANCH" >> $GITHUB_OUTPUT
            echo "branch_sync_status=synced" >> $GITHUB_OUTPUT
            echo "validation_passed=true" >> $GITHUB_OUTPUT
          else
            echo "‚ùå VALIDATION FAILURES DETECTED - Epic branch not ready"
            echo "=========================================="
            exit 1
          fi

      # ========================================
      # Pre-Flight Validation
      # ========================================

      - name: "Restore Dependencies"
        run: dotnet restore zarichney-api.sln

      - name: "Build Solution"
        run: dotnet build zarichney-api.sln --configuration Release --no-restore

      - name: "Validate Test Environment"
        id: test-validation
        run: |
          echo "üß™ Executing test suite validation with fixed exit code handling..."

          # Set CI environment for proper quality gate behavior
          export CI_ENVIRONMENT=true
          export QUALITY_GATE_ENABLED=true
          export COVERAGE_THRESHOLD=16

          # Execute test suite with fixed exit code (our main fix)
          if ./Scripts/run-test-suite.sh report summary; then
            echo "‚úÖ Test suite executed successfully"
            echo "tests-passed=true" >> $GITHUB_OUTPUT
          else
            TEST_EXIT_CODE=$?
            echo "‚ùå Test suite failed with exit code: $TEST_EXIT_CODE"
            echo "tests-passed=false" >> $GITHUB_OUTPUT
            exit $TEST_EXIT_CODE
          fi

      - name: "Process Test Validation Results"
        id: process-validation
        if: always()
        run: |
          echo "üß™ Processing test validation results"

          # Check test execution status
          if [[ "${{ steps.test-validation.outputs.tests-passed }}" == "true" ]]; then
            echo "‚úÖ Test environment validated"
            echo "environment_valid=true" >> $GITHUB_OUTPUT

            # Extract basic metrics from test results (simplified for direct script execution)
            # The script generates TestResults/parsed_results.json with test metrics
            if [ -f "TestResults/parsed_results.json" ]; then
              TOTAL_TESTS=$(jq -r '.tests.total // 0' TestResults/parsed_results.json 2>/dev/null || echo "0")
              SKIPPED_TESTS=$(jq -r '.tests.skipped // 0' TestResults/parsed_results.json 2>/dev/null || echo "0")
              echo "test_metrics=$TOTAL_TESTS total tests, $SKIPPED_TESTS skipped" >> $GITHUB_OUTPUT
            else
              echo "test_metrics=Tests executed successfully" >> $GITHUB_OUTPUT
            fi

            # Extract coverage from results
            if [ -f "TestResults/coverage_results.json" ]; then
              COVERAGE=$(jq -r '.line_coverage // 0' TestResults/coverage_results.json 2>/dev/null || echo "0")
              echo "current_coverage=$COVERAGE" >> $GITHUB_OUTPUT
            else
              echo "current_coverage=16" >> $GITHUB_OUTPUT  # Default baseline
            fi
          else
            echo "‚ùå Test environment validation failed"
            echo "environment_valid=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      # ========================================
      # Coverage Analysis & Scope Selection
      # ========================================

      - name: "Generate Comprehensive Coverage Context"
        id: coverage-analysis
        if: steps.process-validation.outputs.environment_valid == 'true'
        run: |
          echo "üìä Generating comprehensive coverage analysis for AI strategic decision-making"

          # Use coverage from process validation with error handling
          CURRENT_COVERAGE="${{ steps.process-validation.outputs.current_coverage || '16' }}"
          # Remove any existing % symbol and ensure it's added consistently
          CURRENT_COVERAGE=$(echo "$CURRENT_COVERAGE" | sed 's/%//g')
          echo "current_coverage=${CURRENT_COVERAGE}%" >> $GITHUB_OUTPUT

          # Generate coverage summary by area (for AI analysis) with improved fallbacks
          echo "üîç Extracting coverage data by area for AI analysis"
          COVERAGE_CONTEXT=""

          # Enhanced coverage context generation with fallbacks
          if [ -f "coverage_analysis_full.txt" ]; then
            echo "‚úÖ Found coverage_analysis_full.txt - extracting detailed coverage by area"

            # Extract coverage information by major areas
            if grep -q "Services.*%" coverage_analysis_full.txt; then
              SERVICES_COV=$(grep -o "Services.*[0-9]*\.[0-9]*%" coverage_analysis_full.txt | head -1 || echo "Services: Unknown%")
              COVERAGE_CONTEXT="${COVERAGE_CONTEXT}${SERVICES_COV}\n"
            fi

            if grep -q "Controllers.*%" coverage_analysis_full.txt; then
              CONTROLLERS_COV=$(grep -o "Controllers.*[0-9]*\.[0-9]*%" coverage_analysis_full.txt | head -1 || echo "Controllers: Unknown%")
              COVERAGE_CONTEXT="${COVERAGE_CONTEXT}${CONTROLLERS_COV}\n"
            fi

            if grep -q "Repositories.*%" coverage_analysis_full.txt; then
              REPOSITORIES_COV=$(grep -o "Repositories.*[0-9]*\.[0-9]*%" coverage_analysis_full.txt | head -1 || echo "Repositories: Unknown%")
              COVERAGE_CONTEXT="${COVERAGE_CONTEXT}${REPOSITORIES_COV}\n"
            fi

            if grep -q "Utilities.*%" coverage_analysis_full.txt; then
              UTILITIES_COV=$(grep -o "Utilities.*[0-9]*\.[0-9]*%" coverage_analysis_full.txt | head -1 || echo "Utilities: Unknown%")
              COVERAGE_CONTEXT="${COVERAGE_CONTEXT}${UTILITIES_COV}\n"
            fi

            # If no specific areas found, provide general coverage info
            if [ -z "$COVERAGE_CONTEXT" ]; then
              COVERAGE_CONTEXT="Overall Coverage: ${CURRENT_COVERAGE} (from detailed analysis file)\n"
            fi
          else
            echo "‚ö†Ô∏è coverage_analysis_full.txt not found - generating coverage context from available data"
            # Fallback coverage context based on common .NET project structure
            COVERAGE_CONTEXT="Overall Backend Coverage: ${CURRENT_COVERAGE} (from test execution results)\n"
            COVERAGE_CONTEXT="${COVERAGE_CONTEXT}Services Layer: Analysis pending (requires coverage_analysis_full.txt)\n"
            COVERAGE_CONTEXT="${COVERAGE_CONTEXT}Controllers Layer: Analysis pending (requires coverage_analysis_full.txt)\n"
            COVERAGE_CONTEXT="${COVERAGE_CONTEXT}Repository Layer: Analysis pending (requires coverage_analysis_full.txt)\n"
            COVERAGE_CONTEXT="${COVERAGE_CONTEXT}Utilities/Helpers: Analysis pending (requires coverage_analysis_full.txt)\n"
          fi

          # Generate comprehensive coverage summary for AI with improved fallbacks
          if [ -f "coverage_analysis_full.txt" ]; then
            echo "‚úÖ Using detailed coverage analysis file"
            COVERAGE_SUMMARY=$(head -50 coverage_analysis_full.txt | tail -30)
          elif [ -f "TestResults/coverage_results.json" ]; then
            echo "‚úÖ Using coverage results JSON"
            LINE_COV=$(jq -r '.line_coverage // "unknown"' TestResults/coverage_results.json 2>/dev/null || echo "unknown")
            BRANCH_COV=$(jq -r '.branch_coverage // "unknown"' TestResults/coverage_results.json 2>/dev/null || echo "unknown")
            COVERAGE_SUMMARY="Coverage Summary from Test Results:\n"
            COVERAGE_SUMMARY="${COVERAGE_SUMMARY}Line Coverage: ${LINE_COV}%\n"
            COVERAGE_SUMMARY="${COVERAGE_SUMMARY}Branch Coverage: ${BRANCH_COV}%\n"
            COVERAGE_SUMMARY="${COVERAGE_SUMMARY}Test Results: Available in TestResults/ directory\n"
            COVERAGE_SUMMARY="${COVERAGE_SUMMARY}Note: Run './Scripts/run-test-suite.sh report summary' for detailed analysis"
          elif [ -f "TestResults/parsed_results.json" ]; then
            echo "‚úÖ Using parsed test results"
            TOTAL_TESTS=$(jq -r '.tests.total // 0' TestResults/parsed_results.json 2>/dev/null || echo "0")
            PASSED_TESTS=$(jq -r '.tests.passed // 0' TestResults/parsed_results.json 2>/dev/null || echo "0")
            COVERAGE_SUMMARY="Test Execution Summary:\n"
            COVERAGE_SUMMARY="${COVERAGE_SUMMARY}Total Tests: ${TOTAL_TESTS}\n"
            COVERAGE_SUMMARY="${COVERAGE_SUMMARY}Passed Tests: ${PASSED_TESTS}\n"
            COVERAGE_SUMMARY="${COVERAGE_SUMMARY}Coverage: ${CURRENT_COVERAGE}\n"
            COVERAGE_SUMMARY="${COVERAGE_SUMMARY}Status: Test suite executed successfully"
          else
            echo "‚ö†Ô∏è No detailed coverage files available - using basic information"
            COVERAGE_SUMMARY="Basic Coverage Information:\n"
            COVERAGE_SUMMARY="${COVERAGE_SUMMARY}Current Coverage: ${CURRENT_COVERAGE}\n"
            COVERAGE_SUMMARY="${COVERAGE_SUMMARY}Source: Test validation step\n"
            COVERAGE_SUMMARY="${COVERAGE_SUMMARY}Status: Coverage analysis files not generated\n"
            COVERAGE_SUMMARY="${COVERAGE_SUMMARY}Note: Consider running './Scripts/run-test-suite.sh report summary' for detailed analysis"
          fi

          # Output coverage context with error handling
          echo "coverage_by_area<<EOF" >> $GITHUB_OUTPUT
          echo -e "$COVERAGE_CONTEXT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "coverage_summary<<EOF" >> $GITHUB_OUTPUT
          echo -e "$COVERAGE_SUMMARY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          # Prepare manual target area override if specified
          MANUAL_TARGET_AREA="${{ github.event.inputs.target_area }}"
          if [ -n "$MANUAL_TARGET_AREA" ]; then
            echo "manual_target_override=$MANUAL_TARGET_AREA" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Manual target area override: $MANUAL_TARGET_AREA"
          else
            echo "manual_target_override=" >> $GITHUB_OUTPUT
            echo "‚úÖ No manual override - AI will select target area strategically"
          fi

          # Generate unique task identifier (AI will select target area)
          TIMESTAMP=$(date +%s)
          TASK_ID="coverage-ai-strategic-${TIMESTAMP}"
          echo "task_identifier=$TASK_ID" >> $GITHUB_OUTPUT

          echo "üìã Coverage context prepared for AI strategic analysis"
          echo "ü§ñ AI will analyze coverage data and select optimal target area"
          echo "scope_analysis_complete=true" >> $GITHUB_OUTPUT

      - name: "Analyze Pending Work Context"
        id: pending-work-analysis
        if: steps.coverage-analysis.outputs.scope_analysis_complete == 'true'
        run: |
          echo "üîç Analyzing pending work to prevent overlap"

          # Check for pending PRs on the epic branch
          EPIC_PRS=$(gh pr list --base "$EPIC_BRANCH" --json number,title,headRefName,labels --jq '.[] | select(.labels[]?.name | test("(coverage|testing|ai-task)"))')

          if [ -n "$EPIC_PRS" ]; then
            echo "üìã Found pending coverage-related PRs:"
            echo "$EPIC_PRS" | jq -r '"PR #\(.number): \(.title) (Branch: \(.headRefName))"'

            # Extract target areas from PR branches and titles
            PENDING_AREAS=$(echo "$EPIC_PRS" | jq -r '.headRefName' | grep -oE "(services|controllers|repositories|utilities)" | sort -u | tr '\n' ',' | sed 's/,$//')

            echo "pending_pr_context<<EOF" >> $GITHUB_OUTPUT
            if [ -n "$EPIC_PRS" ]; then
              echo "$EPIC_PRS" | jq -c '.'
            else
              echo ""
            fi >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT

            echo "pending_target_areas=$PENDING_AREAS" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Areas with pending work: $PENDING_AREAS"
          else
            echo "‚úÖ No pending coverage-related PRs found on epic branch"
            echo "pending_pr_context=" >> $GITHUB_OUTPUT
            echo "pending_target_areas=" >> $GITHUB_OUTPUT
          fi

          # Use GitHub MCP for enhanced analysis if available
          echo "ü§ñ Attempting enhanced analysis with GitHub MCP"
          MCP_PENDING_ANALYSIS=$(claude --dangerously-skip-permissions --print "Use GitHub MCP to:
          1. List all open PRs in zarichney-api that contain labels 'coverage', 'testing', or 'ai-task'
          2. Analyze their target areas based on branch names and descriptions
          3. Identify any ongoing coverage improvement work
          4. Return summary of areas currently being worked on
          5. Provide recommendations for avoiding overlap" 2>/dev/null || echo "MCP analysis unavailable")

          echo "mcp_pending_analysis<<EOF" >> $GITHUB_OUTPUT
          echo "$MCP_PENDING_ANALYSIS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "pending_analysis_complete=true" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true  # Don't fail workflow if this analysis fails

      # ========================================
      # AI Agent Task Execution
      # ========================================

      - name: "Create Task Branch"
        id: task-branch
        if: steps.coverage-analysis.outputs.scope_analysis_complete == 'true'
        run: |
          TASK_BRANCH="tests/issue-$EPIC_ISSUE_ID-${{ steps.coverage-analysis.outputs.task_identifier }}"
          echo "task_branch_name=$TASK_BRANCH" >> $GITHUB_OUTPUT

          echo "üåø Creating task branch: $TASK_BRANCH"
          git checkout -b "$TASK_BRANCH"

          echo "task_branch_created=true" >> $GITHUB_OUTPUT

      - name: "Prepare Comprehensive AI Context"
        id: task-context
        if: steps.task-branch.outputs.task_branch_created == 'true'
        run: |
          echo "üéØ Preparing comprehensive AI context with error handling and validation"

          # Extract comprehensive context for AI strategic decision-making with validation
          TASK_BRANCH="${{ steps.task-branch.outputs.task_branch_name }}"
          CURRENT_COVERAGE="${{ steps.coverage-analysis.outputs.current_coverage }}"
          TASK_IDENTIFIER="${{ steps.coverage-analysis.outputs.task_identifier }}"

          # Validate required outputs exist
          if [ -z "$TASK_BRANCH" ]; then
            echo "‚ùå ERROR: Task branch name is missing"
            exit 1
          fi

          if [ -z "$CURRENT_COVERAGE" ]; then
            echo "‚ö†Ô∏è WARNING: Current coverage is missing, using default"
            CURRENT_COVERAGE="16%"
          fi

          if [ -z "$TASK_IDENTIFIER" ]; then
            echo "‚ö†Ô∏è WARNING: Task identifier is missing, generating new one"
            TASK_IDENTIFIER="coverage-ai-strategic-$(date +%s)"
          fi

          # Set basic outputs with validation
          echo "task_branch=$TASK_BRANCH" >> $GITHUB_OUTPUT
          echo "current_coverage=$CURRENT_COVERAGE" >> $GITHUB_OUTPUT
          echo "task_identifier=$TASK_IDENTIFIER" >> $GITHUB_OUTPUT
          echo "epic_issue_id=$EPIC_ISSUE_ID" >> $GITHUB_OUTPUT

          echo "‚úÖ Basic AI context outputs set successfully"

          # Pass coverage analysis context with safe handling
          COVERAGE_BY_AREA="${{ steps.coverage-analysis.outputs.coverage_by_area }}"
          if [ -n "$COVERAGE_BY_AREA" ]; then
            echo "coverage_by_area<<EOF" >> $GITHUB_OUTPUT
            echo "$COVERAGE_BY_AREA" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "‚úÖ Coverage by area context passed"
          else
            echo "coverage_by_area<<EOF" >> $GITHUB_OUTPUT
            echo "Overall Backend Coverage: $CURRENT_COVERAGE (context generation pending)" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Using fallback coverage by area context"
          fi

          COVERAGE_SUMMARY="${{ steps.coverage-analysis.outputs.coverage_summary }}"
          if [ -n "$COVERAGE_SUMMARY" ]; then
            echo "coverage_summary<<EOF" >> $GITHUB_OUTPUT
            echo "$COVERAGE_SUMMARY" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "‚úÖ Coverage summary context passed"
          else
            echo "coverage_summary<<EOF" >> $GITHUB_OUTPUT
            echo "Coverage Summary: $CURRENT_COVERAGE from test validation step. Detailed analysis pending." >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Using fallback coverage summary context"
          fi

          # Pass pending work context with safe JSON handling
          # Safe JSON variable assignment using temporary approach
          TEMP_TARGET_FILE=$(mktemp)
          echo '${{ steps.pending-work-analysis.outputs.pending_target_areas }}' > "$TEMP_TARGET_FILE"
          if [ -s "$TEMP_TARGET_FILE" ]; then
            PENDING_TARGET_AREAS=$(cat "$TEMP_TARGET_FILE" | jq -c '.' 2>/dev/null || echo "")
          else
            PENDING_TARGET_AREAS=""
          fi
          rm -f "$TEMP_TARGET_FILE"

          TEMP_OVERRIDE_FILE=$(mktemp)
          echo '${{ steps.coverage-analysis.outputs.manual_target_override }}' > "$TEMP_OVERRIDE_FILE"
          if [ -s "$TEMP_OVERRIDE_FILE" ]; then
            MANUAL_TARGET_OVERRIDE=$(cat "$TEMP_OVERRIDE_FILE" | jq -c '.' 2>/dev/null || echo "")
          else
            MANUAL_TARGET_OVERRIDE=""
          fi
          rm -f "$TEMP_OVERRIDE_FILE"

          echo "pending_target_areas=${PENDING_TARGET_AREAS}" >> $GITHUB_OUTPUT
          echo "manual_target_override=${MANUAL_TARGET_OVERRIDE}" >> $GITHUB_OUTPUT

          echo "‚úÖ Pending work basic context passed"

          # Handle potentially problematic JSON content safely
          # Use GitHub Actions conditional to avoid bash parsing issues
          PR_CONTEXT_EXISTS="${{ steps.pending-work-analysis.outputs.pending_pr_context != '' && 'true' || 'false' }}"
          if [ "$PR_CONTEXT_EXISTS" = "true" ]; then
            # Create a temporary file to safely handle complex JSON content
            TEMP_PR_FILE=$(mktemp)
            echo '${{ steps.pending-work-analysis.outputs.pending_pr_context }}' > "$TEMP_PR_FILE"

            echo "pending_pr_context<<EOF" >> $GITHUB_OUTPUT
            # Use cat to safely output the JSON content
            cat "$TEMP_PR_FILE" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT

            rm -f "$TEMP_PR_FILE"
            echo "‚úÖ Pending PR context passed safely via temporary file"
          else
            echo "pending_pr_context<<EOF" >> $GITHUB_OUTPUT
            echo "No pending coverage-related PRs found on epic branch" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "‚úÖ No pending PR context (expected for clean state)"
          fi

          # Handle MCP analysis context safely
          # Safe JSON variable assignment using temporary approach
          TEMP_MCP_FILE=$(mktemp)
          echo '${{ steps.pending-work-analysis.outputs.mcp_pending_analysis }}' > "$TEMP_MCP_FILE"
          if [ -s "$TEMP_MCP_FILE" ]; then
            MCP_PENDING_ANALYSIS=$(cat "$TEMP_MCP_FILE" | jq -c '.' 2>/dev/null || echo "")
          else
            MCP_PENDING_ANALYSIS=""
          fi
          rm -f "$TEMP_MCP_FILE"

          if [ -n "$MCP_PENDING_ANALYSIS" ] && [ "$MCP_PENDING_ANALYSIS" != "MCP analysis unavailable" ]; then
            echo "mcp_pending_analysis<<EOF" >> $GITHUB_OUTPUT
            echo "$MCP_PENDING_ANALYSIS" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "‚úÖ MCP pending analysis context passed"
          else
            echo "mcp_pending_analysis<<EOF" >> $GITHUB_OUTPUT
            echo "MCP analysis was not available during pending work analysis. Using standard GitHub CLI analysis only." >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "‚úÖ MCP analysis fallback context set"
          fi

          echo "üéØ Comprehensive AI context preparation completed successfully"

      - name: "Check for existing Coverage Epic analysis comment"
        id: check-existing-comment
        if: steps.task-branch.outputs.task_branch_created == 'true' && github.event.inputs.skip_ai_execution != 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // Check for existing unresolved Coverage Epic analysis comments in linked issue
            const issueNumber = ${{ env.EPIC_ISSUE_ID }};
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
            });

            // Check for existing active coverage analysis comments
            const hasActiveAnalysis = comments.data.some(comment => {
              const body = comment.body || '';
              return (
                // Contains the Coverage Epic analysis header
                body.includes('## ü§ñ Coverage Epic AI Agent Report') &&
                // Is not an error message
                !body.includes('Claude encountered an error') &&
                !body.includes('Coverage Epic Analysis Failed') &&
                // Contains substantial analysis content
                (body.includes('### üìä Coverage Improvement Analysis') ||
                 body.includes('Coverage Impact:') ||
                 body.includes('Test Methods Added:'))
              );
            });

            console.log(`Found existing Coverage Epic analysis: ${hasActiveAnalysis}`);
            core.setOutput('skip_analysis', hasActiveAnalysis.toString());

            if (hasActiveAnalysis) {
              console.log('Skipping Coverage Epic analysis - existing active analysis comment found');
            }

      - name: "Load coverage epic prompt with comprehensive context"
        if: steps.check-existing-comment.outputs.skip_analysis != 'true' && github.event.inputs.skip_ai_execution != 'true'
        id: load-coverage-prompt
        run: |
          # Direct file-based approach - completely bypass bash variable processing
          # This eliminates the bash syntax error caused by JSON content with parentheses
          echo "prompt<<PROMPT_EOF" >> $GITHUB_OUTPUT

          # Write prompt template with placeholder replacement directly to output
          cat .github/prompts/coverage-epic-agent.md | sed \
            -e "s/{{CURRENT_COVERAGE}}/${{ steps.task-context.outputs.current_coverage }}%/g" \
            -e "s/{{TASK_IDENTIFIER}}/${{ steps.task-context.outputs.task_identifier }}/g" \
            -e "s/{{EPIC_ISSUE_ID}}/${{ steps.task-context.outputs.epic_issue_id }}/g" \
            -e "s|{{TASK_BRANCH}}|${{ steps.task-context.outputs.task_branch }}|g" >> $GITHUB_OUTPUT

          # Add comprehensive coverage context section directly
          echo "" >> $GITHUB_OUTPUT
          echo "## üìä COMPREHENSIVE COVERAGE ANALYSIS FOR AI STRATEGIC DECISION-MAKING" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo "### **Current Coverage Data by Area**" >> $GITHUB_OUTPUT
          echo "\`\`\`" >> $GITHUB_OUTPUT
          echo "${{ steps.task-context.outputs.coverage_by_area }}" >> $GITHUB_OUTPUT
          echo "\`\`\`" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo "### **Detailed Coverage Summary**" >> $GITHUB_OUTPUT
          echo "\`\`\`" >> $GITHUB_OUTPUT
          echo "${{ steps.task-context.outputs.coverage_summary }}" >> $GITHUB_OUTPUT
          echo "\`\`\`" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo "### **Pending Work Analysis**" >> $GITHUB_OUTPUT
          echo "**Areas Currently Being Worked On:** ${{ steps.task-context.outputs.pending_target_areas }}" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo "**Pending PR Context:**" >> $GITHUB_OUTPUT
          echo "\`\`\`json" >> $GITHUB_OUTPUT

          # Use safe temporary file approach for problematic JSON content
          TEMP_PR_FILE=$(mktemp)
          echo '${{ steps.task-context.outputs.pending_pr_context }}' > "$TEMP_PR_FILE"
          cat "$TEMP_PR_FILE" >> $GITHUB_OUTPUT
          rm -f "$TEMP_PR_FILE"

          echo "\`\`\`" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo "**Enhanced MCP Analysis:**" >> $GITHUB_OUTPUT
          echo "\`\`\`" >> $GITHUB_OUTPUT
          echo "${{ steps.task-context.outputs.mcp_pending_analysis }}" >> $GITHUB_OUTPUT
          echo "\`\`\`" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo "### **Manual Target Override**" >> $GITHUB_OUTPUT
          if [ -n "${{ steps.task-context.outputs.manual_target_override }}" ]; then
            echo "**MANUAL OVERRIDE SPECIFIED:** ${{ steps.task-context.outputs.manual_target_override }}" >> $GITHUB_OUTPUT
          else
            echo "**NO MANUAL OVERRIDE** - AI has full strategic decision-making authority" >> $GITHUB_OUTPUT
          fi
          echo "" >> $GITHUB_OUTPUT
          echo "## üéØ YOUR STRATEGIC MISSION: INTELLIGENT TARGET AREA SELECTION" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo "**You must now analyze the above data and:**" >> $GITHUB_OUTPUT
          echo "1. **Select the optimal target area** based on coverage gaps and priority" >> $GITHUB_OUTPUT
          echo "2. **Avoid areas with pending work** to prevent overlap and conflicts" >> $GITHUB_OUTPUT
          echo "3. **Consider coverage phase alignment** and strategic value" >> $GITHUB_OUTPUT
          echo "4. **Choose 1-3 related files** in your selected area for focused implementation" >> $GITHUB_OUTPUT
          echo "5. **Justify your selection** in your implementation notes" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo "**CRITICAL:** You are NOT constrained to any predetermined area. Use your intelligence to make the best strategic decision for maximum coverage impact." >> $GITHUB_OUTPUT
          echo "PROMPT_EOF" >> $GITHUB_OUTPUT

      - name: "Debug Manual Trigger Context"
        if: github.event_name == 'workflow_dispatch'
        run: |
          echo "üîç Manual Trigger Debug Information"
          echo "Event Name: ${{ github.event_name }}"
          echo "Repository: ${{ github.repository }}"
          echo "Skip AI Execution Input: ${{ github.event.inputs.skip_ai_execution }}"
          echo "Skip Analysis Check: ${{ steps.check-existing-comment.outputs.skip_analysis }}"
          echo "Claude OAuth Token Present: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN != '' }}"
          echo "Scheduled Trigger Input: ${{ github.event.inputs.scheduled_trigger }}"
          echo "AI Execution Condition Evaluation:"
          echo "  - skip_analysis != 'true': ${{ steps.check-existing-comment.outputs.skip_analysis != 'true' }}"
          echo "  - skip_ai_execution != 'true': ${{ github.event.inputs.skip_ai_execution != 'true' }}"
          echo "  - Combined Condition: ${{ steps.check-existing-comment.outputs.skip_analysis != 'true' && github.event.inputs.skip_ai_execution != 'true' }}"

      # Removed preflight probing; rely on actual action outcome + post-failure classification

      - name: "Execute Coverage Epic AI Agent"
        if: steps.check-existing-comment.outputs.skip_analysis != 'true' && github.event.inputs.skip_ai_execution != 'true'
        id: claude-coverage
        uses: anthropics/claude-code-action@v1
        continue-on-error: true  # Gracefully handle subscription quota/time-window limits
        with:
          prompt: ${{ steps.load-coverage-prompt.outputs.prompt }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          github_token: ${{ secrets.GITHUB_TOKEN }}
          # Enable non-interactive execution of required tools for CI
          claude_args: |
            --allowedTools "Edit,Read,Write,MultiEdit,Bash(./Scripts/*),Bash(dotnet build:*),Bash(dotnet test:*),Bash(dotnet restore:*),Bash(dotnet format:*),Bash(ls:*),Bash(pwd:*),Bash(find:*),Bash(grep:*),Bash(cat:*),Bash(head:*),Bash(tail:*),Bash(jq:*)"

      - name: "Classify Claude Failure Reason"
        id: claude-classify
        if: always() && steps.task-branch.outputs.task_branch_created == 'true' && steps.claude-coverage.outcome == 'failure'
        shell: bash
        run: |
          echo "üîé Classifying Claude failure reason"
          CLASS="unexpected"
          if command -v claude >/dev/null 2>&1; then
            set +e
            OUT=$(claude --dangerously-skip-permissions --print "ping" 2>&1)
            EC=$?
            set -e
            if [ $EC -ne 0 ] && echo "$OUT" | grep -Ei "(quota|rate limit|limit.*reached|time window|subscription|try again later|currently unavailable)" >/dev/null; then
              CLASS="quota_window"
            fi
          else
            # If CLI not available, fall back to scheduled context assumption to avoid noise in background runs
            if [ "${{ github.event.inputs.scheduled_trigger }}" = "true" ]; then
              CLASS="quota_window"
            fi
          fi
          echo "ai_failure_class=$CLASS" >> $GITHUB_OUTPUT
          echo "Classification: $CLASS"

      - name: "Handle Coverage Epic AI Failure"
        if: failure() && steps.claude-coverage.outcome == 'failure'
        uses: ./.github/actions/handle-ai-analysis-failure
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          analysis-type: 'Coverage Epic Agent'
          analysis-emoji: 'ü§ñ'
          analysis-name: 'Coverage Epic Analysis'
          standards-link: 'https://github.com/Zarichney-Development/zarichney-api/blob/main/Docs/Standards/TestingStandards.md'
          run-number: ${{ github.run_number }}
          run-id: ${{ github.run_id }}

      - name: "Set AI Execution Status"
        id: ai-execution
        if: always() && steps.task-branch.outputs.task_branch_created == 'true'
        run: |
          if [ "${{ github.event.inputs.skip_ai_execution }}" = "true" ]; then
            echo "ai_execution_status=skipped_manual_override" >> $GITHUB_OUTPUT
            echo "coverage_improvements=AI execution skipped - manual override (infrastructure testing mode)" >> $GITHUB_OUTPUT
          elif [ "${{ steps.check-existing-comment.outputs.skip_analysis }}" = "true" ]; then
            echo "ai_execution_status=skipped_existing_analysis" >> $GITHUB_OUTPUT
            echo "coverage_improvements=Skipped - existing analysis found in Epic Issue #$EPIC_ISSUE_ID" >> $GITHUB_OUTPUT
          elif [ "${{ steps.claude-coverage.outcome }}" = "success" ]; then
            echo "ai_execution_status=claude_success" >> $GITHUB_OUTPUT
            echo "coverage_improvements=Claude AI agent completed coverage improvements successfully" >> $GITHUB_OUTPUT
          elif [ "${{ steps.claude-coverage.outcome }}" = "failure" ] && [ "${{ steps.claude-classify.outputs.ai_failure_class }}" = "quota_window" ]; then
            echo "ai_execution_status=skipped_quota_window" >> $GITHUB_OUTPUT
            echo "coverage_improvements=Skipped - Claude Code quota/time window not available for this interval; will retry next schedule" >> $GITHUB_OUTPUT
          elif [ "${{ steps.claude-coverage.outcome }}" = "failure" ]; then
            echo "ai_execution_status=claude_failure" >> $GITHUB_OUTPUT
            echo "coverage_improvements=Claude AI agent encountered an unexpected error during execution" >> $GITHUB_OUTPUT
          else
            echo "ai_execution_status=not_executed" >> $GITHUB_OUTPUT
            echo "coverage_improvements=AI agent was not executed" >> $GITHUB_OUTPUT
          fi

      - name: "Fail on unexpected Claude errors (manual runs)"
        if: always() && steps.task-branch.outputs.task_branch_created == 'true' && github.event.inputs.skip_ai_execution != 'true' && steps.check-existing-comment.outputs.skip_analysis != 'true' && github.event.inputs.scheduled_trigger != 'true' && steps.claude-coverage.outcome == 'failure' && steps.claude-classify.outputs.ai_failure_class != 'quota_window'
        run: |
          echo "::error::Claude Code execution failed during a non-scheduled run. Marking job as failed."
          exit 1

      - name: "Fail on unexpected Claude errors (scheduled runs)"
        if: always() && steps.task-branch.outputs.task_branch_created == 'true' && github.event.inputs.skip_ai_execution != 'true' && steps.check-existing-comment.outputs.skip_analysis != 'true' && github.event.inputs.scheduled_trigger == 'true' && steps.claude-coverage.outcome == 'failure' && steps.claude-classify.outputs.ai_failure_class != 'quota_window'
        run: |
          echo "::error::Claude Code execution failed during a scheduled run for a reason other than quota/time window. Marking job as failed."
          exit 1

      - name: "Clean AI Transcript Artifacts"
        if: always()
        run: |
          # Remove any AI transcript files that should not be committed
          if [ -f "output.txt" ]; then
            echo "üßπ Removing AI transcript file: output.txt"
            rm -f output.txt || true
          fi

      # ========================================
      # Quality Gates & Validation
      # ========================================

      - name: "Validate Infrastructure & Test Suite"
        id: post-validation
        if: always() && steps.ai-execution.outputs.ai_execution_status != ''
        run: |
          echo "üîç Validating infrastructure and test suite status"

          AI_STATUS="${{ steps.ai-execution.outputs.ai_execution_status }}"
          echo "üìã AI Execution Status: $AI_STATUS"

          # Build validation to ensure no regressions
          echo "üî® Validating build integrity"
          if dotnet build zarichney-api.sln --configuration Release --no-restore; then
            echo "‚úÖ Build validation passed - no build regressions"
            BUILD_STATUS="passed"
          else
            echo "‚ùå Build validation failed - infrastructure needs attention"
            BUILD_STATUS="failed"
          fi

          # Test suite validation (basic health check)
          echo "üß™ Validating test suite health"
          if ./Scripts/run-test-suite.sh report summary > post_test_summary.txt 2>&1; then
            echo "‚úÖ Test suite execution completed"

            # Check for expected test patterns
            if grep -q "100%" post_test_summary.txt && grep -q "skipped" post_test_summary.txt; then
              echo "‚úÖ Test suite maintains expected patterns (100% pass rate with skips)"
              TEST_STATUS="healthy"
            else
              echo "‚ö†Ô∏è Test suite patterns may have changed"
              TEST_STATUS="changed"
            fi

            # Show summary for transparency
            echo "üìä Test execution summary:"
            grep -E "(passed|failed|skipped|Total)" post_test_summary.txt | head -5 | sed 's/^/  /'

          else
            echo "‚ùå Test suite execution failed"
            TEST_STATUS="failed"
            echo "üìã Error details:"
            tail -10 post_test_summary.txt | sed 's/^/  /'
          fi

          # Determine overall validation status
          if [ "$BUILD_STATUS" = "passed" ] && [ "$TEST_STATUS" != "failed" ]; then
            if [ "$AI_STATUS" = "claude_success" ]; then
              echo "‚úÖ Infrastructure validation passed - Claude AI agent executed successfully"
              echo "üìà Coverage improvements implemented by autonomous AI agent"
              echo "üöÄ Epic #$EPIC_ISSUE_ID progression: Real AI-powered test generation completed"

            elif [ "$AI_STATUS" = "skipped_existing_analysis" ]; then
              echo "‚è≠Ô∏è Infrastructure healthy - AI analysis skipped (existing analysis found)"
              echo "üí° Review existing analysis in Epic Issue #$EPIC_ISSUE_ID"

            elif [ "$AI_STATUS" = "skipped_manual_override" ]; then
              echo "‚úÖ Infrastructure validation passed - AI execution skipped (manual override)"
              echo "ü§ñ Triggered by: ${{ github.event.inputs.trigger_source || 'workflow_dispatch' }}"
              echo "üìã Reason: ${{ github.event.inputs.trigger_reason || 'Manual execution' }}"
              echo "‚ö†Ô∏è Mode: Infrastructure testing only - AI agent execution disabled"

            elif [ "$AI_STATUS" = "claude_failure" ]; then
              echo "‚ö†Ô∏è Infrastructure healthy but Claude AI agent encountered issues"
              echo "üìã Check workflow logs and error handling for details"

            else
              echo "‚ö†Ô∏è Infrastructure validation completed with status: $AI_STATUS"
            fi

            echo "validation_passed=true" >> $GITHUB_OUTPUT
            echo "infrastructure_status=ready" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Infrastructure validation failed"
            echo "üîß Build Status: $BUILD_STATUS"
            echo "üß™ Test Status: $TEST_STATUS"
            echo "validation_passed=false" >> $GITHUB_OUTPUT
            echo "infrastructure_status=needs_attention" >> $GITHUB_OUTPUT
          fi

          # Cleanup
          rm -f post_test_summary.txt

      # ========================================
      # Automated Pull Request Creation
      # ========================================

      - name: "Commit Coverage Improvements"
        id: commit-changes
        # Only commit if validation passed AND AI execution completed successfully
        if: steps.post-validation.outputs.validation_passed == 'true' && steps.ai-execution.outputs.ai_execution_status == 'claude_success'
        run: |
          echo "üíæ Committing coverage improvements"

          # Check if there are changes to commit
          if git diff --quiet && git diff --cached --quiet; then
            echo "‚ö†Ô∏è No changes detected - AI agent may not have implemented improvements"
            echo "changes_committed=false" >> $GITHUB_OUTPUT
          else
            # Commit all changes
            git add -A
            git commit -m "test: improve coverage with AI strategic analysis (#$EPIC_ISSUE_ID)

            Automated coverage improvement for Epic #$EPIC_ISSUE_ID

            - AI Strategic Selection: Coverage improvements selected by AI analysis
            - Current Coverage: ${{ steps.coverage-analysis.outputs.current_coverage }}
            - Task ID: ${{ steps.coverage-analysis.outputs.task_identifier }}
            - AI Improvements: ${{ steps.ai-execution.outputs.coverage_improvements }}
            - Environment: CI (${EXPECTED_SKIP_COUNT:-23} tests skipped, 100% pass rate maintained; see Docs/Standards/TestingStandards.md section 12.7)

            ü§ñ Generated with Coverage Epic Automation
            Co-Authored-By: Coverage Epic Bot <noreply@zarichney.dev>"

            # Push task branch
            git push origin "${{ steps.task-branch.outputs.task_branch_name }}"

            echo "changes_committed=true" >> $GITHUB_OUTPUT
          fi

      - name: "Check for Existing Pull Request"
        id: check-existing-pr
        if: steps.commit-changes.outputs.changes_committed == 'true'
        run: |
          echo "üîç Checking for existing pull request on task branch"

          TASK_BRANCH="${{ steps.task-branch.outputs.task_branch_name }}"

          # Check if PR already exists for this task branch
          EXISTING_PR=$(gh pr list --head "$TASK_BRANCH" --json number,url,state --jq '.[0] // empty')

          if [ -n "$EXISTING_PR" ]; then
            PR_NUMBER=$(echo "$EXISTING_PR" | jq -r '.number')
            PR_URL=$(echo "$EXISTING_PR" | jq -r '.url')
            PR_STATE=$(echo "$EXISTING_PR" | jq -r '.state')

            echo "‚ö†Ô∏è Existing pull request found for branch $TASK_BRANCH"
            echo "   PR #$PR_NUMBER: $PR_URL (State: $PR_STATE)"
            echo "   Skipping duplicate PR creation"

            echo "pr_exists=true" >> $GITHUB_OUTPUT
            echo "existing_pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
            echo "existing_pr_url=$PR_URL" >> $GITHUB_OUTPUT
            echo "existing_pr_state=$PR_STATE" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ No existing pull request found for branch $TASK_BRANCH"
            echo "   Proceeding with PR creation"
            echo "pr_exists=false" >> $GITHUB_OUTPUT
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: "Enhanced PR Analysis with GitHub MCP"
        id: mcp-pr-analysis
        if: steps.commit-changes.outputs.changes_committed == 'true'
        run: |
          echo "üîç Performing enhanced PR analysis with GitHub MCP"

          TASK_BRANCH="${{ steps.task-branch.outputs.task_branch_name }}"
          # TARGET_AREA is determined by AI strategic analysis, not predefined

          # Use GitHub MCP for intelligent PR analysis and validation
          MCP_ANALYSIS=$(claude --dangerously-skip-permissions --print "Use GitHub MCP to:
          1. Check if a PR exists for branch '$TASK_BRANCH' in zarichney-api repository
          2. If no PR exists, validate that creating a PR is appropriate
          3. Analyze recent commits on this branch for coverage improvements
          4. Provide recommendations for PR title and description enhancements
          5. Return JSON with: {\"pr_exists\": boolean, \"recommendations\": string, \"should_create_pr\": boolean}" 2>/dev/null || echo "{\"error\": \"MCP analysis failed\"}")

          echo "mcp_analysis_result<<EOF" >> $GITHUB_OUTPUT
          echo "$MCP_ANALYSIS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          # Log MCP analysis for transparency
          echo "üìä MCP Analysis Result:"
          echo "$MCP_ANALYSIS" | head -10
        continue-on-error: true  # Don't fail the workflow if MCP is unavailable

      - name: "Create Pull Request"
        id: create-pr
        if: steps.commit-changes.outputs.changes_committed == 'true' && steps.check-existing-pr.outputs.pr_exists == 'false'
        run: |
          echo "üìù Creating automated pull request"

          PR_TITLE="test: improve coverage with AI strategic analysis (#$EPIC_ISSUE_ID)"

          PR_BODY="## Coverage Improvement Summary

          **Epic Reference:** [Backend Testing Coverage to 90%](https://github.com/Zarichney-Development/zarichney-api/issues/$EPIC_ISSUE_ID)
          **Target Area:** AI strategic selection based on coverage analysis
          **Current Coverage:** ${{ steps.coverage-analysis.outputs.current_coverage }}
          **Task Identifier:** ${{ steps.coverage-analysis.outputs.task_identifier }}

          ### Automated Implementation
          - ü§ñ **Execution Model:** Autonomous AI agent in CI environment
          - üéØ **Scope:** Self-selected based on coverage analysis
          - ‚úÖ **Quality Gates:** 100% pass rate maintained on executable tests
          - üìä **Coverage Phase:** Aligned with current coverage progression strategy

          ### Changes Made
          ${{ steps.ai-execution.outputs.coverage_improvements }}

          ### Test Environment Validation
          - ‚úÖ **Executable Tests:** 100% pass rate maintained
          - ‚úÖ **Expected Skips:** ${EXPECTED_SKIP_COUNT:-23} tests skipped (external dependencies unavailable; see Docs/Standards/TestingStandards.md section 12.7)
          - ‚úÖ **Build Status:** Clean build with no regressions
          - ‚úÖ **Standards Compliance:** All testing standards followed

          ### Epic Progress Contribution
          This automated task contributes to the systematic progression toward 90% backend test coverage by January 2026, maintaining the target velocity of ~2.8% monthly improvement.

          ### AI Analysis Insights
          **Enhanced Analysis via GitHub MCP:**
          ${{ steps.mcp-pr-analysis.outputs.mcp_analysis_result != '' && steps.mcp-pr-analysis.outputs.mcp_analysis_result != '{"error": "MCP analysis failed"}' && '‚úÖ MCP analysis completed - See additional insights below' || '‚ö†Ô∏è MCP analysis unavailable - Standard pipeline analysis used' }}

          ${{ steps.mcp-pr-analysis.outputs.mcp_analysis_result != '' && steps.mcp-pr-analysis.outputs.mcp_analysis_result != '{"error": "MCP analysis failed"}' && 'üìä **Analysis Summary:** Enhanced PR validation completed with GitHub MCP integration' || '' }}

          ---

          ü§ñ **Generated by Coverage Epic Automation**
          **Execution Time:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')
          **Agent Coordination:** Timestamp-based conflict prevention active
          **Epic Branch:** \`$EPIC_BRANCH\`
          **Duplicate Prevention:** ‚úÖ PR existence validated before creation"

          # Create PR using GitHub CLI with standards-compliant labels
          if gh pr create \
            --base "$EPIC_BRANCH" \
            --title "$PR_TITLE" \
            --body "$PR_BODY" \
            --label "type: coverage,automation: agent-generated,epic: coverage-90,component: testing,priority: medium,effort: small" \
            --draft=false; then

            PR_URL=$(gh pr view --json url --jq .url)
            echo "pr_created=true" >> $GITHUB_OUTPUT
            echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT

            echo "‚úÖ Pull request created successfully: $PR_URL"
          else
            echo "‚ùå Failed to create pull request"
            echo "üîç Checking if labels exist in repository..."

            # Verify required labels exist
            REQUIRED_LABELS=("type: coverage" "automation: agent-generated" "epic: coverage-90" "component: testing" "priority: medium" "effort: small")
            MISSING_LABELS=()

            for label in "${REQUIRED_LABELS[@]}"; do
              if ! gh label list --search "$label" | grep -q "^$label"; then
                MISSING_LABELS+=("$label")
              fi
            done

            if [ ${#MISSING_LABELS[@]} -gt 0 ]; then
              echo "‚ùå Missing required labels:"
              printf '  - %s\n' "${MISSING_LABELS[@]}"
              echo "üìã Please create missing labels according to GitHubLabelStandards.md"
            else
              echo "‚úÖ All required labels exist - PR creation failed for other reasons"
              echo "üìã Check repository permissions and branch protection rules"
            fi

            echo "pr_created=false" >> $GITHUB_OUTPUT
            exit 1
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # ========================================
      # Execution Summary & Metrics
      # ========================================

      - name: "Execution Summary"
        if: always()
        run: |
          echo "=================================================="
          echo "üéØ Coverage Epic Automation Execution Summary"
          echo "=================================================="
          echo "üìÖ Execution Time: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "üöÄ Trigger Source: ${{ github.event.inputs.trigger_source || 'manual' }}"
          echo "üìù Trigger Reason: ${{ github.event.inputs.trigger_reason || 'Manual execution' }}"
          echo "ü§ñ Scheduled: ${{ github.event.inputs.scheduled_trigger || 'false' }}"
          echo "üåø Epic Branch: $EPIC_BRANCH"
          echo "üéØ Target Area: AI strategic selection (determined by Claude analysis)"
          echo "üìä Current Coverage: ${{ steps.coverage-analysis.outputs.current_coverage || 'Unknown' }}"
          echo "üî¢ Task ID: ${{ steps.coverage-analysis.outputs.task_identifier || 'Not generated' }}"
          echo ""
          echo "üìã Step Results:"
          echo "  Epic Branch Ready: ${{ steps.epic-branch.outputs.epic_branch_ready || 'false' }}"
          echo "  Environment Valid: ${{ steps.process-validation.outputs.environment_valid || 'false' }}"
          echo "  Scope Analysis: ${{ steps.coverage-analysis.outputs.scope_analysis_complete || 'false' }}"
          echo "  Task Branch: ${{ steps.task-branch.outputs.task_branch_created || 'false' }}"
          echo "  AI Execution: ${{ steps.ai-execution.outputs.ai_execution_status || 'not_executed' }}"
          echo "  Post-Validation: ${{ steps.post-validation.outputs.validation_passed || 'false' }}"
          echo "  Changes Committed: ${{ steps.commit-changes.outputs.changes_committed || 'false' }}"
          echo "  PR Exists Check: ${{ steps.check-existing-pr.outputs.pr_exists || 'not_checked' }}"
          echo "  MCP Analysis: ${{ steps.mcp-pr-analysis.outputs.mcp_analysis_result != '' && 'completed' || 'not_available' }}"
          echo "  PR Created: ${{ steps.create-pr.outputs.pr_created || 'false' }}"
          echo ""
          if [ "${{ steps.create-pr.outputs.pr_created }}" = "true" ]; then
            echo "üéâ SUCCESS: Pull request created successfully"
            echo "üîó PR URL: ${{ steps.create-pr.outputs.pr_url }}"
            echo "üìà Epic #$EPIC_ISSUE_ID progression continues"
          elif [ "${{ steps.check-existing-pr.outputs.pr_exists }}" = "true" ]; then
            echo "‚úÖ SUCCESS: Changes committed to existing pull request"
            echo "üîó Existing PR: ${{ steps.check-existing-pr.outputs.existing_pr_url }}"
            echo "üìù PR #${{ steps.check-existing-pr.outputs.existing_pr_number }} (State: ${{ steps.check-existing-pr.outputs.existing_pr_state }})"
            echo "üìà Epic #$EPIC_ISSUE_ID progression continues via existing PR"
          elif [ "${{ steps.commit-changes.outputs.changes_committed }}" = "true" ]; then
            echo "‚ö†Ô∏è PARTIAL: Changes committed but PR creation skipped"
            echo "üîç Check PR creation logic and permissions"
          else
            echo "‚ÑπÔ∏è NO ACTION: No changes were made to commit"
            echo "üîç Check AI execution status and scope selection"
          fi
          echo "=================================================="

      - name: "Cleanup on Failure"
        if: failure()
        run: |
          echo "üßπ Cleaning up after failed execution"

          # Remove task branch if created but not successfully used
          if [ "${{ steps.task-branch.outputs.task_branch_created }}" = "true" ] &&
             [ "${{ steps.commit-changes.outputs.changes_committed }}" != "true" ]; then
            TASK_BRANCH="${{ steps.task-branch.outputs.task_branch_name }}"
            echo "üóëÔ∏è Removing unused task branch: $TASK_BRANCH"
            git checkout $EPIC_BRANCH 2>/dev/null || git checkout develop
            git branch -D "$TASK_BRANCH" 2>/dev/null || true
          fi

          echo "üîç Failure cleanup completed"
