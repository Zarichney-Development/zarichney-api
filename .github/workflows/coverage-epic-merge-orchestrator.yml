name: "Coverage Epic Merge Orchestrator"

# Coverage Epic Merge Orchestrator Workflow
# Autonomously discovers, stages, validates, and merges Coverage Epic PRs
# Uses AI conflict resolution for complex merge scenarios
# Execution via workflow_dispatch only - triggered manually or by orchestration

on:
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run mode (preview actions without executing)'
        required: false
        default: true
        type: boolean
      max_prs:
        description: 'Maximum PRs to process in single run'
        required: false
        default: '8'
        type: string
      pr_label_filter:
        description: 'Comma-separated PR label filters (OR logic with flexible matching)'
        required: false
        default: 'type: coverage,coverage,testing,ai-task'
        type: string
      sync_epic_from_develop:
        description: 'Sync epic branch from develop before merging PRs'
        required: false
        default: true
        type: boolean
      merge_strategy:
        description: 'Merge strategy for consolidation'
        required: false
        default: 'merge'
        type: choice
        options:
          - 'merge'
          - 'squash'

# Single concurrency group to prevent parallel orchestrator runs
concurrency:
  group: coverage-epic-merge
  cancel-in-progress: false

env:
  DOTNET_VERSION: '8.0.x'
  EPIC_BRANCH: 'epic/testing-coverage-to-90'
  EPIC_ISSUE_ID: '94'

permissions:
  id-token: write
  contents: write
  actions: read
  pull-requests: write
  issues: write

jobs:
  merge-orchestrator:
    name: "Coverage Epic Merge Orchestrator"
    runs-on: ubuntu-latest

    # Only run on main repository (not forks)
    if: github.repository == 'Zarichney-Development/zarichney-api'

    steps:
      # ========================================
      # Environment Setup & Validation
      # ========================================

      - name: "Checkout Repository"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Need full history for merge operations
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: "Setup Development Environment"
        uses: ./.github/actions/shared/setup-environment
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}
          setup-node: false
          cache-dependencies: true

      - name: "Configure Git for Merge Operations"
        run: |
          git config --global user.name "Coverage Epic Merge Bot"
          git config --global user.email "noreply@zarichney.dev"
          git config --global init.defaultBranch main

      - name: "Validate Input Parameters"
        id: validate-inputs
        run: |
          echo "üîç Validating orchestrator input parameters"

          # Validate max_prs is a positive integer
          MAX_PRS="${{ github.event.inputs.max_prs }}"
          if ! [[ "$MAX_PRS" =~ ^[1-9][0-9]*$ ]] || [ "$MAX_PRS" -gt 50 ]; then
            echo "‚ùå Invalid max_prs: $MAX_PRS (must be 1-50)"
            exit 1
          fi

          # Validate merge strategy
          MERGE_STRATEGY="${{ github.event.inputs.merge_strategy }}"
          if [[ ! "$MERGE_STRATEGY" =~ ^(merge|squash)$ ]]; then
            echo "‚ùå Invalid merge_strategy: $MERGE_STRATEGY"
            exit 1
          fi

          # Parse and validate label filters
          LABEL_FILTER="${{ github.event.inputs.pr_label_filter }}"
          IFS=',' read -ra LABELS <<< "$LABEL_FILTER"
          VALID_LABELS=()
          for label in "${LABELS[@]}"; do
            label=$(echo "$label" | xargs)  # Trim whitespace
            if [ -n "$label" ]; then
              VALID_LABELS+=("$label")
            fi
          done

          if [ ${#VALID_LABELS[@]} -eq 0 ]; then
            echo "‚ùå No valid labels found in filter: $LABEL_FILTER"
            exit 1
          fi

          echo "‚úÖ Input validation passed"
          echo "max_prs=$MAX_PRS" >> $GITHUB_OUTPUT
          echo "merge_strategy=$MERGE_STRATEGY" >> $GITHUB_OUTPUT
          printf -v JOINED_LABELS '%s,' "${VALID_LABELS[@]}"
          echo "label_filters=${JOINED_LABELS%,}" >> $GITHUB_OUTPUT
          echo "dry_run=${{ github.event.inputs.dry_run }}" >> $GITHUB_OUTPUT

      # ========================================
      # Epic Branch Preparation
      # ========================================

      - name: "Prepare Epic Branch"
        id: epic-preparation
        run: |
          echo "üîÑ Preparing epic branch for merge orchestration"

          # Fetch all remote data
          git fetch --all --prune

          # Ensure epic branch exists and is properly tracked
          if ! git show-ref --verify --quiet refs/heads/$EPIC_BRANCH; then
            if git ls-remote --heads origin "$EPIC_BRANCH" | grep -q "$EPIC_BRANCH"; then
              echo "üì• Creating local epic branch from remote"
              git checkout -b $EPIC_BRANCH origin/$EPIC_BRANCH
            else
              echo "‚ùå Epic branch does not exist locally or remotely"
              exit 1
            fi
          else
            echo "‚úÖ Local epic branch exists"
            git checkout $EPIC_BRANCH
          fi

          # Sync epic branch from develop if requested
          if [ "${{ github.event.inputs.sync_epic_from_develop }}" = "true" ]; then
            echo "üîÑ Syncing epic branch with develop"
            git fetch origin develop
            
            # Check if develop integration is needed
            DEVELOP_COMMIT=$(git rev-parse origin/develop)
            EPIC_BASE=$(git merge-base $EPIC_BRANCH origin/develop)
            
            if [ "$EPIC_BASE" != "$DEVELOP_COMMIT" ]; then
              echo "üîÑ Epic branch needs develop integration"
              
              if [ "${{ steps.validate-inputs.outputs.dry_run }}" = "false" ]; then
                # Attempt merge
                if git merge origin/develop --no-edit; then
                  echo "‚úÖ Epic branch synced with develop successfully"
                  git push origin $EPIC_BRANCH
                else
                  echo "‚ö†Ô∏è Merge conflicts detected during develop sync"
                  git merge --abort
                  echo "sync_conflicts=true" >> $GITHUB_OUTPUT
                  echo "üìã Manual resolution required before PR orchestration"
                fi
              else
                echo "üîç DRY RUN: Would sync epic branch with develop"
              fi
            else
              echo "‚úÖ Epic branch already up-to-date with develop"
            fi
          fi

          CURRENT_COMMIT=$(git rev-parse HEAD)
          echo "epic_commit=$CURRENT_COMMIT" >> $GITHUB_OUTPUT
          echo "epic_ready=true" >> $GITHUB_OUTPUT

      # ========================================
      # PR Discovery & Filtering
      # ========================================

      - name: "Discover Coverage PRs"
        id: pr-discovery
        if: steps.epic-preparation.outputs.epic_ready == 'true'
        run: |
          echo "üîç Discovering mergeable coverage PRs targeting epic branch"

          # Get all PRs targeting the epic branch
          ALL_PRS=$(gh pr list --base "$EPIC_BRANCH" --state open --json number,title,headRefName,labels,url,mergeable)

          if [ -z "$ALL_PRS" ] || [ "$ALL_PRS" = "[]" ]; then
            echo "‚ÑπÔ∏è No open PRs found targeting epic branch"
            echo "discovered_prs=[]" >> $GITHUB_OUTPUT
            echo "total_prs=0" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "üìã Found $(echo "$ALL_PRS" | jq length) total PRs targeting epic branch"

          # Filter PRs by labels with flexible matching
          LABEL_FILTERS="${{ steps.validate-inputs.outputs.label_filters }}"
          IFS=',' read -ra FILTER_ARRAY <<< "$LABEL_FILTERS"

          # Build flexible pattern for OR matching (escape special regex chars)
          PATTERN_PARTS=()
          for label in "${FILTER_ARRAY[@]}"; do
            # Escape special regex characters and allow flexible matching
            escaped_label=$(echo "$label" | sed 's/[(){}|^$*+?\[\]\.]/\\&/g' | sed 's/: /: ?/g')
            PATTERN_PARTS+=("$escaped_label")
          done
          
          # Join patterns with OR logic
          printf -v LABEL_PATTERN '%s|' "${PATTERN_PARTS[@]}"
          LABEL_PATTERN=${LABEL_PATTERN%|}
          
          echo "üè∑Ô∏è Using label pattern: $LABEL_PATTERN"

          # Apply label filtering with OR logic
          FILTERED_PRS=$(echo "$ALL_PRS" | jq --arg pattern "$LABEL_PATTERN" '
            map(select(.labels[]?.name | test($pattern)))
          ')

          echo "üìã Found $(echo "$FILTERED_PRS" | jq length) PRs matching label filters"

          # Filter by mergeable status (include both MERGEABLE and UNKNOWN for flexibility)
          MERGEABLE_PRS=$(echo "$FILTERED_PRS" | jq '
            map(select(.mergeable == "MERGEABLE" or .mergeable == "UNKNOWN" or .mergeable == true))
          ')

          TOTAL_MERGEABLE=$(echo "$MERGEABLE_PRS" | jq length)
          echo "üìã Found $TOTAL_MERGEABLE mergeable PRs"

          # Limit to max PRs
          MAX_PRS=${{ steps.validate-inputs.outputs.max_prs }}
          if [ "$TOTAL_MERGEABLE" -gt "$MAX_PRS" ]; then
            echo "‚ö†Ô∏è Limiting to first $MAX_PRS PRs (out of $TOTAL_MERGEABLE mergeable)"
            FINAL_PRS=$(echo "$MERGEABLE_PRS" | jq ".[0:$MAX_PRS]")
          else
            FINAL_PRS="$MERGEABLE_PRS"
            echo "‚úÖ Processing all $TOTAL_MERGEABLE discovered PRs (within $MAX_PRS limit)"
          fi

          # Output discovered PRs with detailed validation
          echo "üìä Final PR selection for orchestration:"
          echo "$FINAL_PRS" | jq -r '.[] | "  PR #\(.number): \(.title) (Branch: \(.headRefName))"'
          
          # Enhanced validation for 8-PR scenario
          if [ $(echo "$FINAL_PRS" | jq length) -ge 8 ]; then
            echo "‚úÖ Successfully discovered 8+ PRs for merge orchestration"
          elif [ $(echo "$FINAL_PRS" | jq length) -gt 0 ]; then
            echo "‚ÑπÔ∏è Discovered $(echo "$FINAL_PRS" | jq length) PRs (less than 8-PR test scenario)"
          fi
          
          # Display PR details for validation
          echo "üìã PR Labels and Mergeable Status:"
          echo "$FINAL_PRS" | jq -r '.[] | "  PR #\(.number) [\(.mergeable)]: \(.labels | map(.name) | join(", "))"'

          # Save results with random delimiter
          EOF_DISCOVERED_PRS=$(dd if=/dev/urandom bs=15 count=1 status=none | base64)
          echo "discovered_prs<<$EOF_DISCOVERED_PRS" >> $GITHUB_OUTPUT
          echo "$FINAL_PRS" >> $GITHUB_OUTPUT
          echo "$EOF_DISCOVERED_PRS" >> $GITHUB_OUTPUT

          echo "total_prs=$(echo "$FINAL_PRS" | jq length)" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # ========================================
      # Direct Sequential PR Merging
      # ========================================

      - name: "Prepare Epic Branch for Direct Merging"
        id: epic-merge-prep
        if: steps.pr-discovery.outputs.total_prs != '0'
        run: |
          echo "üéØ Preparing epic branch for direct PR merging"

          # Ensure we're on the epic branch
          git checkout $EPIC_BRANCH
          
          # Get current epic branch commit for rollback if needed
          EPIC_STARTING_COMMIT=$(git rev-parse HEAD)
          echo "üìç Epic branch starting commit: $EPIC_STARTING_COMMIT"
          
          if [ "${{ steps.validate-inputs.outputs.dry_run }}" = "false" ]; then
            echo "‚úÖ Epic branch ready for direct PR merging"
          else
            echo "üîç DRY RUN: Would prepare epic branch for direct merging"
          fi

          echo "epic_starting_commit=$EPIC_STARTING_COMMIT" >> $GITHUB_OUTPUT
          echo "merge_prep_complete=true" >> $GITHUB_OUTPUT

      - name: "Direct Sequential PR Merging with AI Conflict Resolution"
        id: pr-merging
        if: steps.epic-merge-prep.outputs.merge_prep_complete == 'true'
        run: |
          echo "üîÑ Beginning direct sequential PR merging into epic branch"

          # Ensure we're on the epic branch
          git checkout $EPIC_BRANCH

          # Parse discovered PRs
          DISCOVERED_PRS='${{ steps.pr-discovery.outputs.discovered_prs }}'
          TOTAL_PRS=$(echo "$DISCOVERED_PRS" | jq length)
          
          echo "üìä Processing $TOTAL_PRS PRs for direct merging into epic branch"

          SUCCESSFUL_MERGES=()
          FAILED_MERGES=()
          CONFLICT_RESOLUTIONS=()
          AI_INTERVENTIONS=()

          # Process each PR sequentially with direct merging
          for i in $(seq 0 $((TOTAL_PRS - 1))); do
            PR_DATA=$(echo "$DISCOVERED_PRS" | jq -r ".[$i]")
            PR_NUMBER=$(echo "$PR_DATA" | jq -r '.number')
            PR_BRANCH=$(echo "$PR_DATA" | jq -r '.headRefName')
            PR_TITLE=$(echo "$PR_DATA" | jq -r '.title')

            echo ""
            echo "üéØ Processing PR #$PR_NUMBER: $PR_TITLE"
            echo "   Branch: $PR_BRANCH"
            echo "   Target: Direct merge into $EPIC_BRANCH"

            if [ "${{ steps.validate-inputs.outputs.dry_run }}" = "true" ]; then
              echo "üîç DRY RUN: Would attempt direct merge of PR #$PR_NUMBER"
              SUCCESSFUL_MERGES+=("$PR_NUMBER")
              continue
            fi

            # Attempt direct PR merge using GitHub CLI
            echo "üîÑ Attempting direct merge of PR #$PR_NUMBER..."
            
            # First check if PR is still mergeable
            PR_MERGEABLE=$(gh pr view "$PR_NUMBER" --json mergeable --jq '.mergeable')
            if [ "$PR_MERGEABLE" = "CONFLICTING" ]; then
              echo "‚ö†Ô∏è PR #$PR_NUMBER has conflicts - attempting AI resolution"
              
              # Fetch PR branch for manual conflict resolution
              git fetch origin "$PR_BRANCH"
              
              # Attempt merge to trigger conflict state
              if ! git merge "origin/$PR_BRANCH" --no-edit; then
                echo "ü§ñ Invoking AI conflict resolution for PR #$PR_NUMBER"
                
                # Mark this as needing AI intervention
                AI_INTERVENTIONS+=("$PR_NUMBER")
                CONFLICT_RESOLUTIONS+=("$PR_NUMBER")
                
                # Abort merge to clean state
                git merge --abort
                
                echo "üîÑ PR #$PR_NUMBER marked for AI conflict resolution"
                FAILED_MERGES+=("$PR_NUMBER")
              else
                echo "‚úÖ Manual merge successful for PR #$PR_NUMBER"
                git push origin $EPIC_BRANCH
                SUCCESSFUL_MERGES+=("$PR_NUMBER")
                
                # Close the PR since we manually merged it
                gh pr close "$PR_NUMBER" --comment "Merged directly into epic branch via Coverage Epic Merge Orchestrator"
              fi
            else
              # Try direct GitHub PR merge
              if gh pr merge "$PR_NUMBER" --${{ steps.validate-inputs.outputs.merge_strategy }} --delete-branch=false; then
                echo "‚úÖ Successfully merged PR #$PR_NUMBER via GitHub CLI"
                SUCCESSFUL_MERGES+=("$PR_NUMBER")
              else
                echo "‚ö†Ô∏è GitHub CLI merge failed for PR #$PR_NUMBER - attempting manual resolution"
                
                # Fall back to manual merge
                git fetch origin "$PR_BRANCH"
                if git merge "origin/$PR_BRANCH" --no-edit; then
                  echo "‚úÖ Manual merge successful for PR #$PR_NUMBER"
                  git push origin $EPIC_BRANCH
                  SUCCESSFUL_MERGES+=("$PR_NUMBER")
                  
                  # Close the PR
                  gh pr close "$PR_NUMBER" --comment "Merged directly into epic branch via Coverage Epic Merge Orchestrator"
                else
                  echo "‚ùå Merge conflicts require AI resolution for PR #$PR_NUMBER"
                  git merge --abort
                  AI_INTERVENTIONS+=("$PR_NUMBER")
                  CONFLICT_RESOLUTIONS+=("$PR_NUMBER")
                  FAILED_MERGES+=("$PR_NUMBER")
                fi
              fi
            fi
          done

          # Report results
          echo ""
          echo "üìä Direct Merging Results Summary:"
          echo "   Total PRs Processed: $TOTAL_PRS"
          echo "   Successful Merges: ${#SUCCESSFUL_MERGES[@]} PRs"
          echo "   Failed Merges: ${#FAILED_MERGES[@]} PRs"
          echo "   AI Interventions Needed: ${#AI_INTERVENTIONS[@]} PRs"
          
          if [ ${#SUCCESSFUL_MERGES[@]} -gt 0 ]; then
            printf '   Successfully merged: %s\n' "${SUCCESSFUL_MERGES[@]}"
          fi
          
          if [ ${#FAILED_MERGES[@]} -gt 0 ]; then
            printf '   Failed merges: %s\n' "${FAILED_MERGES[@]}"
          fi
          
          if [ ${#AI_INTERVENTIONS[@]} -gt 0 ]; then
            printf '   AI interventions needed: %s\n' "${AI_INTERVENTIONS[@]}"
          fi

          # Save results
          printf -v SUCCESSFUL_JSON '%s,' "${SUCCESSFUL_MERGES[@]}"
          echo "successful_merges=[${SUCCESSFUL_JSON%,}]" >> $GITHUB_OUTPUT

          printf -v FAILED_JSON '%s,' "${FAILED_MERGES[@]}"
          echo "failed_merges=[${FAILED_JSON%,}]" >> $GITHUB_OUTPUT

          printf -v AI_JSON '%s,' "${AI_INTERVENTIONS[@]}"
          echo "ai_interventions=[${AI_JSON%,}]" >> $GITHUB_OUTPUT

          echo "successful_count=${#SUCCESSFUL_MERGES[@]}" >> $GITHUB_OUTPUT
          echo "failed_count=${#FAILED_MERGES[@]}" >> $GITHUB_OUTPUT
          echo "ai_intervention_count=${#AI_INTERVENTIONS[@]}" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # ========================================
      # AI Conflict Resolution
      # ========================================

      - name: "Load AI Conflict Resolution Prompt"
        if: steps.pr-merging.outputs.ai_intervention_count != '0' && steps.validate-inputs.outputs.dry_run == 'false'
        id: load-ai-prompt
        run: |
          echo "ü§ñ Loading AI conflict resolution prompt for direct epic branch conflicts"

          # Prepare conflict context for direct epic branch resolution
          FAILED_MERGES='${{ steps.pr-merging.outputs.failed_merges }}'
          AI_INTERVENTIONS='${{ steps.pr-merging.outputs.ai_interventions }}'
          EPIC_STARTING_COMMIT="${{ steps.epic-merge-prep.outputs.epic_starting_commit }}"

          PROMPT_DELIMITER=$(dd if=/dev/urandom bs=15 count=1 status=none | base64)
          echo "ai_prompt<<$PROMPT_DELIMITER" >> $GITHUB_OUTPUT

          # Load prompt template for direct epic branch conflict resolution
          if [ -f ".github/prompts/coverage-epic-merge-orchestrator.md" ]; then
            cat .github/prompts/coverage-epic-merge-orchestrator.md | sed \
              -e "s/{{EPIC_BRANCH}}/$EPIC_BRANCH/g" \
              -e "s/{{FAILED_MERGES}}/$FAILED_MERGES/g" \
              -e "s/{{AI_INTERVENTIONS}}/$AI_INTERVENTIONS/g" \
              -e "s/{{EPIC_STARTING_COMMIT}}/$EPIC_STARTING_COMMIT/g" \
              -e "s/{{EPIC_ISSUE_ID}}/$EPIC_ISSUE_ID/g" >> $GITHUB_OUTPUT
          else
            # Enhanced fallback prompt for direct epic branch conflict resolution
            echo "# Coverage Epic Merge Orchestrator - Direct Epic Branch AI Conflict Resolution" >> $GITHUB_OUTPUT
            echo "" >> $GITHUB_OUTPUT
            echo "You are the Coverage Epic Merge Orchestrator AI assistant operating directly on the epic branch." >> $GITHUB_OUTPUT
            echo "" >> $GITHUB_OUTPUT
            echo "## Context" >> $GITHUB_OUTPUT
            echo "- **Operation Mode**: Direct sequential PR merging into epic branch" >> $GITHUB_OUTPUT
            echo "- **Epic Branch**: $EPIC_BRANCH" >> $GITHUB_OUTPUT
            echo "- **Epic Starting State**: $EPIC_STARTING_COMMIT" >> $GITHUB_OUTPUT
            echo "- **Failed Merges**: $FAILED_MERGES" >> $GITHUB_OUTPUT
            echo "- **PRs Requiring AI Intervention**: $AI_INTERVENTIONS" >> $GITHUB_OUTPUT
            echo "- **Epic Issue**: #$EPIC_ISSUE_ID" >> $GITHUB_OUTPUT
            echo "" >> $GITHUB_OUTPUT
            echo "## Task" >> $GITHUB_OUTPUT
            echo "Resolve merge conflicts for failed PRs by operating directly on the $EPIC_BRANCH branch." >> $GITHUB_OUTPUT
            echo "" >> $GITHUB_OUTPUT
            echo "### Specific Instructions:" >> $GITHUB_OUTPUT
            echo "1. For each failed PR, fetch its branch and attempt merge into current epic branch state" >> $GITHUB_OUTPUT
            echo "2. When conflicts occur, resolve them intelligently while preserving all coverage improvements" >> $GITHUB_OUTPUT
            echo "3. Focus on maintaining test coverage progression and avoiding regression" >> $GITHUB_OUTPUT
            echo "4. After resolving conflicts for a PR, commit the merge and continue to the next PR" >> $GITHUB_OUTPUT
            echo "5. Push changes to epic branch after successful conflict resolution" >> $GITHUB_OUTPUT
            echo "6. Close resolved PRs with appropriate merge messages" >> $GITHUB_OUTPUT
            echo "" >> $GITHUB_OUTPUT
            echo "### Conflict Resolution Priorities:" >> $GITHUB_OUTPUT
            echo "- Preserve all test coverage improvements from both branches" >> $GITHUB_OUTPUT
            echo "- Maintain code quality and standards compliance" >> $GITHUB_OUTPUT
            echo "- Ensure all tests continue to pass after resolution" >> $GITHUB_OUTPUT
            echo "- Document resolution approach in commit messages" >> $GITHUB_OUTPUT
          fi

          echo "$PROMPT_DELIMITER" >> $GITHUB_OUTPUT

      - name: "Execute AI Direct Epic Branch Conflict Resolution"
        if: steps.load-ai-prompt.outputs.ai_prompt != '' && steps.validate-inputs.outputs.dry_run == 'false'
        id: ai-resolution
        uses: anthropics/claude-code-action@v1
        continue-on-error: true
        with:
          prompt: ${{ steps.load-ai-prompt.outputs.ai_prompt }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          github_token: ${{ secrets.GITHUB_TOKEN }}
          claude_args: |
            --allowedTools "Edit,Read,Write,MultiEdit,Bash(git:*),Bash(gh:*),Bash(dotnet:*),Bash(./Scripts/*),Bash(ls:*),Bash(grep:*),Bash(find:*)"

      # ========================================
      # Validation & Testing
      # ========================================

      - name: "Validate Epic Branch After Direct Merging"
        id: validation
        if: steps.pr-merging.outputs.successful_count != '0' || steps.ai-resolution.conclusion == 'success'
        run: |
          echo "üîç Validating epic branch integrity after direct merging"

          # Ensure we're on the epic branch
          git checkout $EPIC_BRANCH
          
          # Pull any changes that might have been made by AI resolution
          git pull origin $EPIC_BRANCH

          if [ "${{ steps.validate-inputs.outputs.dry_run }}" = "true" ]; then
            echo "üîç DRY RUN: Would validate epic branch after direct merging"
            echo "validation_passed=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Build validation
          echo "üî® Validating build integrity on epic branch"
          if dotnet build zarichney-api.sln --configuration Release --no-restore; then
            echo "‚úÖ Build validation passed"
            BUILD_VALID=true
          else
            echo "‚ùå Build validation failed on epic branch"
            BUILD_VALID=false
          fi

          # Test execution validation
          echo "üß™ Running test suite validation on epic branch"
          if ./Scripts/run-test-suite.sh report summary; then
            echo "‚úÖ Test suite validation passed"
            TESTS_VALID=true
          else
            echo "‚ùå Test suite validation failed on epic branch"
            TESTS_VALID=false
          fi

          # Overall validation
          if [ "$BUILD_VALID" = true ] && [ "$TESTS_VALID" = true ]; then
            echo "‚úÖ Epic branch validation passed after direct merging"
            echo "validation_passed=true" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Epic branch validation failed after direct merging"
            echo "validation_passed=false" >> $GITHUB_OUTPUT
            
            # If validation failed, consider rollback
            echo "‚ö†Ô∏è Consider rolling back epic branch to: ${{ steps.epic-merge-prep.outputs.epic_starting_commit }}"
          fi

      # ========================================
      # Epic Branch Status Update
      # ========================================

      - name: "Update Epic Issue with Direct Merge Results"
        id: epic-status-update
        if: steps.validation.outputs.validation_passed == 'true' && (steps.pr-merging.outputs.successful_count != '0' || steps.ai-resolution.conclusion == 'success')
        run: |
          echo "üìù Updating epic issue with direct merge orchestration results"

          SUCCESSFUL_MERGES='${{ steps.pr-merging.outputs.successful_merges }}'
          FAILED_MERGES='${{ steps.pr-merging.outputs.failed_merges }}'
          AI_INTERVENTIONS='${{ steps.pr-merging.outputs.ai_interventions }}'
          
          if [ "${{ steps.validate-inputs.outputs.dry_run }}" = "true" ]; then
            echo "üîç DRY RUN: Would update epic issue with direct merge results"
            echo "epic_updated=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Create status update comment for epic issue
          TIMESTAMP=$(date -u '+%Y-%m-%d %H:%M:%S UTC')
          UPDATE_TITLE="## ü§ñ Coverage Epic Merge Orchestrator - Direct Sequential Merging Complete"

          # Build update body components
          UPDATE_INTRO="The Coverage Epic Merge Orchestrator has completed direct sequential PR merging into the epic branch."
          UPDATE_SUMMARY="### üìä Direct Merging Summary"
          UPDATE_EXEC="- **Execution Time**: $TIMESTAMP"
          UPDATE_TARGET="- **Target Branch**: \`$EPIC_BRANCH\` (direct merging)"
          UPDATE_SUCCESS="- **Successful Direct Merges**: ${{ steps.pr-merging.outputs.successful_count }} PRs"
          UPDATE_FAILED="- **Failed Merges**: ${{ steps.pr-merging.outputs.failed_count }} PRs"
          UPDATE_AI="- **AI Conflict Resolutions**: ${{ steps.pr-merging.outputs.ai_intervention_count }} PRs"
          UPDATE_STRATEGY="- **Merge Strategy**: ${{ steps.validate-inputs.outputs.merge_strategy }}"
          
          # Combine sections
          UPDATE_BODY=$(printf '%s\n\n%s\n\n%s\n%s\n%s\n%s\n%s\n%s\n%s' \
            "$UPDATE_TITLE" "$UPDATE_INTRO" "$UPDATE_SUMMARY" \
            "$UPDATE_EXEC" "$UPDATE_TARGET" "$UPDATE_SUCCESS" \
            "$UPDATE_FAILED" "$UPDATE_AI" "$UPDATE_STRATEGY")
          
          # Add successful merges list
          if [ "${{ steps.pr-merging.outputs.successful_count }}" != "0" ]; then
            UPDATE_BODY="${UPDATE_BODY}\n\n### ‚úÖ Successfully Merged PRs (Direct to Epic Branch)"
            SUCCESS_LIST=$(echo "$SUCCESSFUL_MERGES" | jq -r '.[] | "- PR #\(.) - Merged directly into epic branch"' 2>/dev/null || echo "- No successful merges")
            UPDATE_BODY="${UPDATE_BODY}\n${SUCCESS_LIST}"
          fi

          # Add AI intervention results if any
          if [ "${{ steps.pr-merging.outputs.ai_intervention_count }}" != "0" ]; then
            UPDATE_BODY="${UPDATE_BODY}\n\n### ü§ñ AI Conflict Resolution Results"
            if [ "${{ steps.ai-resolution.conclusion }}" = "success" ]; then
              UPDATE_BODY="${UPDATE_BODY}\n- ‚úÖ **AI Resolution Status**: Successful conflict resolution"
              AI_LIST=$(echo "$AI_INTERVENTIONS" | jq -r '.[] | "- PR #\(.) - Conflicts resolved by AI assistant"' 2>/dev/null || echo "- No AI interventions")
              UPDATE_BODY="${UPDATE_BODY}\n${AI_LIST}"
            else
              UPDATE_BODY="${UPDATE_BODY}\n- ‚ö†Ô∏è **AI Resolution Status**: Some conflicts may require manual intervention"
            fi
          fi

          # Add validation results
          UPDATE_BODY="${UPDATE_BODY}\n\n### üß™ Epic Branch Validation Results"
          UPDATE_BODY="${UPDATE_BODY}\n- ‚úÖ **Build Status**: Epic branch builds successfully"
          UPDATE_BODY="${UPDATE_BODY}\n- ‚úÖ **Test Suite**: All tests pass on epic branch"
          UPDATE_BODY="${UPDATE_BODY}\n- ‚úÖ **Quality Gates**: Standards compliance maintained"
          
          # Add impact section
          UPDATE_BODY="${UPDATE_BODY}\n\n### üìà Epic Progress Impact"
          UPDATE_BODY="${UPDATE_BODY}\nDirect PR merging has advanced the systematic progression toward 90% backend test coverage by January 2026."
          UPDATE_BODY="${UPDATE_BODY}\n\nüéØ **Epic Progress**: Backend Testing Coverage to 90% goal"
          UPDATE_BODY="${UPDATE_BODY}\nü§ñ **Generated by Coverage Epic Merge Orchestrator**"
          UPDATE_BODY="${UPDATE_BODY}\n**Execution Time**: $TIMESTAMP"

          # Post update to epic issue
          if echo "$UPDATE_BODY" | gh issue comment $EPIC_ISSUE_ID --body-file -; then
            echo "‚úÖ Epic issue updated successfully"
            echo "epic_updated=true" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Failed to update epic issue"
            echo "epic_updated=false" >> $GITHUB_OUTPUT
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # ========================================
      # Cleanup & Error Recovery
      # ========================================

      - name: "Cleanup Temporary Resources"
        if: always()
        run: |
          echo "üßπ Cleaning up temporary resources after direct merging"

          if [ "${{ steps.validate-inputs.outputs.dry_run }}" = "false" ]; then
            # Ensure we're on epic branch
            git checkout $EPIC_BRANCH 2>/dev/null || git checkout develop
            
            # Clean up any temporary branches that might have been created
            echo "üóëÔ∏è Cleaning up any temporary branches"
            
            # Remove any local branches that might have been created during conflict resolution
            git branch | grep "temp-merge-" | xargs -r git branch -D || true
            
            echo "‚úÖ Resource cleanup completed"
          else
            echo "üîç DRY RUN: Would cleanup temporary resources"
          fi

      - name: "Error Recovery & Audit Trail"
        if: failure()
        run: |
          echo "üö® Merge orchestrator encountered errors - implementing recovery"

          # Create audit trail for direct merging failure
          TIMESTAMP=$(date -u '+%Y-%m-%d %H:%M:%S UTC')
          AUDIT_COMMENT=$(printf '%s\n\n%s\n%s\n%s\n\n%s\n%s\n%s\n%s\n%s\n%s\n\n%s\n%s\n%s\n%s\n%s\n\n%s\n%s\n%s\n%s\n\n%s' \
            "## üö® Coverage Epic Merge Orchestrator Failure (Direct Merging Mode)" \
            "**Execution Time**: $TIMESTAMP" \
            "**Error Context**: Workflow failed during direct sequential PR merging" \
            "**Epic Branch**: \`$EPIC_BRANCH\`" \
            "### üìä Execution State" \
            "- **PRs Discovered**: ${{ steps.pr-discovery.outputs.total_prs || '0' }}" \
            "- **Operation Mode**: Direct sequential merging into epic branch" \
            "- **Epic Starting Commit**: ${{ steps.epic-merge-prep.outputs.epic_starting_commit || 'Unknown' }}" \
            "- **Successful Direct Merges**: ${{ steps.pr-merging.outputs.successful_count || '0' }}" \
            "- **Failed Merges**: ${{ steps.pr-merging.outputs.failed_count || '0' }}" \
            "- **AI Interventions**: ${{ steps.pr-merging.outputs.ai_intervention_count || '0' }}" \
            "### üîç Recovery Actions Needed" \
            "1. Review workflow logs for specific failure points during direct merging" \
            "2. Check epic branch state - may need rollback to: ${{ steps.epic-merge-prep.outputs.epic_starting_commit || 'starting commit' }}" \
            "3. Identify which PRs were successfully merged before failure" \
            "4. Consider manual resolution of remaining PRs" \
            "5. Validate epic branch integrity before proceeding" \
            "### üõ°Ô∏è Safety Measures" \
            "- Epic branch can be rolled back to starting state if needed" \
            "- All original PRs remain available for manual processing" \
            "- Failed PRs identified for individual attention" \
            "**Manual intervention may be required to complete direct merging orchestration.**")

          # Post audit comment to epic issue
          if [ -n "${{ secrets.GITHUB_TOKEN }}" ]; then
            echo "$AUDIT_COMMENT" | gh issue comment $EPIC_ISSUE_ID --body-file - || true
            echo "üìù Audit trail posted to Epic Issue #$EPIC_ISSUE_ID"
          fi

      # ========================================
      # Execution Summary
      # ========================================

      - name: "Orchestrator Execution Summary"
        if: always()
        run: |
          echo "=================================================="
          echo "üéØ Coverage Epic Merge Orchestrator Summary"
          echo "=================================================="
          echo "üìÖ Execution Time: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "üîß Mode: ${{ steps.validate-inputs.outputs.dry_run == 'true' && 'DRY RUN' || 'LIVE EXECUTION' }}"
          echo "üåø Epic Branch: $EPIC_BRANCH"
          echo "üéØ Operation Mode: Direct sequential merging into epic branch"
          echo "üîÑ Epic Starting Commit: ${{ steps.epic-merge-prep.outputs.epic_starting_commit || 'Unknown' }}"
          echo "üìä Max PRs Configured: ${{ steps.validate-inputs.outputs.max_prs || 'Unknown' }}"
          echo "üè∑Ô∏è Label Filters: ${{ steps.validate-inputs.outputs.label_filters || 'Unknown' }}"
          echo ""
          echo "üìã Direct Merging Orchestration Results:"
          echo "  PRs Discovered: ${{ steps.pr-discovery.outputs.total_prs || '0' }}"
          echo "  Successful Direct Merges: ${{ steps.pr-merging.outputs.successful_count || '0' }}"
          echo "  Failed Merges: ${{ steps.pr-merging.outputs.failed_count || '0' }}"
          echo "  AI Conflict Resolutions: ${{ steps.pr-merging.outputs.ai_intervention_count || '0' }}"
          echo "  Epic Branch Validation: ${{ steps.validation.outputs.validation_passed || 'false' }}"
          echo "  Epic Issue Updated: ${{ steps.epic-status-update.outputs.epic_updated || 'false' }}"
          echo ""
          if [ "${{ steps.epic-status-update.outputs.epic_updated }}" = "true" ] && [ "${{ steps.validation.outputs.validation_passed }}" = "true" ]; then
            echo "üéâ SUCCESS: Coverage Epic direct merge orchestration completed"
            echo "üéØ Epic Branch: All PRs merged directly into $EPIC_BRANCH"
            echo "üìà Epic #$EPIC_ISSUE_ID progression continues with direct merging approach"
          elif [ "${{ steps.pr-discovery.outputs.total_prs }}" = "0" ]; then
            echo "‚ÑπÔ∏è NO ACTION: No mergeable PRs found for direct orchestration"
          else
            echo "‚ö†Ô∏è PARTIAL: Some PRs processed via direct merging but orchestration incomplete"
            echo "üîç Check individual step results and epic branch state"
            if [ -n "${{ steps.epic-merge-prep.outputs.epic_starting_commit }}" ]; then
              echo "üîÑ Epic branch can be rolled back to: ${{ steps.epic-merge-prep.outputs.epic_starting_commit }}"
            fi
          fi
          echo "=================================================="