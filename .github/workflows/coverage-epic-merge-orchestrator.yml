name: "Coverage Epic Merge Orchestrator"

# Coverage Epic Merge Orchestrator Workflow
# Autonomously discovers, stages, validates, and merges Coverage Epic PRs
# Uses AI conflict resolution for complex merge scenarios
# Execution via workflow_dispatch only - triggered manually or by orchestration

on:
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run mode (preview actions without executing)'
        required: false
        default: true
        type: boolean
      max_prs:
        description: 'Maximum PRs to process in single run'
        required: false
        default: '8'
        type: string
      pr_label_filter:
        description: 'Comma-separated PR label filters (OR logic with flexible matching)'
        required: false
        default: 'type: coverage,coverage,testing,ai-task'
        type: string
      sync_epic_from_develop:
        description: 'Sync epic branch from develop before merging PRs'
        required: false
        default: true
        type: boolean
      merge_strategy:
        description: 'Merge strategy for consolidation'
        required: false
        default: 'merge'
        type: choice
        options:
          - 'merge'
          - 'squash'

# Single concurrency group to prevent parallel orchestrator runs
concurrency:
  group: coverage-epic-merge
  cancel-in-progress: false

env:
  DOTNET_VERSION: '8.0.x'
  EPIC_BRANCH: 'epic/testing-coverage-to-90'
  EPIC_ISSUE_ID: '94'

permissions:
  id-token: write
  contents: write
  actions: read
  pull-requests: write
  issues: write

jobs:
  merge-orchestrator:
    name: "Coverage Epic Merge Orchestrator"
    runs-on: ubuntu-latest

    # Only run on main repository (not forks)
    if: github.repository == 'Zarichney-Development/zarichney-api'

    steps:
      # ========================================
      # Environment Setup & Validation
      # ========================================

      - name: "Checkout Repository"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Need full history for merge operations
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: "Setup Development Environment"
        uses: ./.github/actions/shared/setup-environment
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}
          setup-node: false
          cache-dependencies: true

      - name: "Configure Git for Merge Operations"
        run: |
          git config --global user.name "Coverage Epic Merge Bot"
          git config --global user.email "noreply@zarichney.dev"
          git config --global init.defaultBranch main

      - name: "Validate Input Parameters"
        id: validate-inputs
        run: |
          echo "üîç Validating orchestrator input parameters"

          # Validate max_prs is a positive integer
          MAX_PRS="${{ github.event.inputs.max_prs }}"
          if ! [[ "$MAX_PRS" =~ ^[1-9][0-9]*$ ]] || [ "$MAX_PRS" -gt 50 ]; then
            echo "‚ùå Invalid max_prs: $MAX_PRS (must be 1-50)"
            exit 1
          fi

          # Validate merge strategy
          MERGE_STRATEGY="${{ github.event.inputs.merge_strategy }}"
          if [[ ! "$MERGE_STRATEGY" =~ ^(merge|squash)$ ]]; then
            echo "‚ùå Invalid merge_strategy: $MERGE_STRATEGY"
            exit 1
          fi

          # Parse and validate label filters
          LABEL_FILTER="${{ github.event.inputs.pr_label_filter }}"
          IFS=',' read -ra LABELS <<< "$LABEL_FILTER"
          VALID_LABELS=()
          for label in "${LABELS[@]}"; do
            label=$(echo "$label" | xargs)  # Trim whitespace
            if [ -n "$label" ]; then
              VALID_LABELS+=("$label")
            fi
          done

          if [ ${#VALID_LABELS[@]} -eq 0 ]; then
            echo "‚ùå No valid labels found in filter: $LABEL_FILTER"
            exit 1
          fi

          echo "‚úÖ Input validation passed"
          echo "max_prs=$MAX_PRS" >> $GITHUB_OUTPUT
          echo "merge_strategy=$MERGE_STRATEGY" >> $GITHUB_OUTPUT
          printf -v JOINED_LABELS '%s,' "${VALID_LABELS[@]}"
          echo "label_filters=${JOINED_LABELS%,}" >> $GITHUB_OUTPUT
          echo "dry_run=${{ github.event.inputs.dry_run }}" >> $GITHUB_OUTPUT

      # ========================================
      # Epic Branch Preparation
      # ========================================

      - name: "Prepare Epic Branch"
        id: epic-preparation
        run: |
          echo "üîÑ Preparing epic branch for merge orchestration"

          # Fetch all remote data
          git fetch --all --prune

          # Ensure epic branch exists and is properly tracked
          if ! git show-ref --verify --quiet refs/heads/$EPIC_BRANCH; then
            if git ls-remote --heads origin "$EPIC_BRANCH" | grep -q "$EPIC_BRANCH"; then
              echo "üì• Creating local epic branch from remote"
              git checkout -b $EPIC_BRANCH origin/$EPIC_BRANCH
            else
              echo "‚ùå Epic branch does not exist locally or remotely"
              exit 1
            fi
          else
            echo "‚úÖ Local epic branch exists"
            git checkout $EPIC_BRANCH
          fi

          # Sync epic branch from develop if requested
          if [ "${{ github.event.inputs.sync_epic_from_develop }}" = "true" ]; then
            echo "üîÑ Syncing epic branch with develop"
            git fetch origin develop
            
            # Check if develop integration is needed
            DEVELOP_COMMIT=$(git rev-parse origin/develop)
            EPIC_BASE=$(git merge-base $EPIC_BRANCH origin/develop)
            
            if [ "$EPIC_BASE" != "$DEVELOP_COMMIT" ]; then
              echo "üîÑ Epic branch needs develop integration"
              
              if [ "${{ steps.validate-inputs.outputs.dry_run }}" = "false" ]; then
                # Attempt merge
                if git merge origin/develop --no-edit; then
                  echo "‚úÖ Epic branch synced with develop successfully"
                  git push origin $EPIC_BRANCH
                else
                  echo "‚ö†Ô∏è Merge conflicts detected during develop sync"
                  git merge --abort
                  echo "sync_conflicts=true" >> $GITHUB_OUTPUT
                  echo "üìã Manual resolution required before PR orchestration"
                fi
              else
                echo "üîç DRY RUN: Would sync epic branch with develop"
              fi
            else
              echo "‚úÖ Epic branch already up-to-date with develop"
            fi
          fi

          CURRENT_COMMIT=$(git rev-parse HEAD)
          echo "epic_commit=$CURRENT_COMMIT" >> $GITHUB_OUTPUT
          echo "epic_ready=true" >> $GITHUB_OUTPUT

      # ========================================
      # PR Discovery & Filtering
      # ========================================

      - name: "Discover Coverage PRs"
        id: pr-discovery
        if: steps.epic-preparation.outputs.epic_ready == 'true'
        run: |
          echo "üîç Discovering mergeable coverage PRs targeting epic branch"

          # Get all PRs targeting the epic branch
          ALL_PRS=$(gh pr list --base "$EPIC_BRANCH" --state open --json number,title,headRefName,labels,url,mergeable)

          if [ -z "$ALL_PRS" ] || [ "$ALL_PRS" = "[]" ]; then
            echo "‚ÑπÔ∏è No open PRs found targeting epic branch"
            echo "discovered_prs=[]" >> $GITHUB_OUTPUT
            echo "total_prs=0" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "üìã Found $(echo "$ALL_PRS" | jq length) total PRs targeting epic branch"

          # Filter PRs by labels with flexible matching
          LABEL_FILTERS="${{ steps.validate-inputs.outputs.label_filters }}"
          IFS=',' read -ra FILTER_ARRAY <<< "$LABEL_FILTERS"

          # Build flexible pattern for OR matching (escape special regex chars)
          PATTERN_PARTS=()
          for label in "${FILTER_ARRAY[@]}"; do
            # Escape special regex characters and allow flexible matching
            escaped_label=$(echo "$label" | sed 's/[(){}|^$*+?\[\]\.]/\\&/g' | sed 's/: /: ?/g')
            PATTERN_PARTS+=("$escaped_label")
          done
          
          # Join patterns with OR logic
          printf -v LABEL_PATTERN '%s|' "${PATTERN_PARTS[@]}"
          LABEL_PATTERN=${LABEL_PATTERN%|}
          
          echo "üè∑Ô∏è Using label pattern: $LABEL_PATTERN"

          # Apply label filtering with OR logic
          FILTERED_PRS=$(echo "$ALL_PRS" | jq --arg pattern "$LABEL_PATTERN" '
            map(select(.labels[]?.name | test($pattern)))
          ')

          echo "üìã Found $(echo "$FILTERED_PRS" | jq length) PRs matching label filters"

          # Filter by mergeable status (include both MERGEABLE and UNKNOWN for flexibility)
          MERGEABLE_PRS=$(echo "$FILTERED_PRS" | jq '
            map(select(.mergeable == "MERGEABLE" or .mergeable == "UNKNOWN" or .mergeable == true))
          ')

          TOTAL_MERGEABLE=$(echo "$MERGEABLE_PRS" | jq length)
          echo "üìã Found $TOTAL_MERGEABLE mergeable PRs"

          # Limit to max PRs
          MAX_PRS=${{ steps.validate-inputs.outputs.max_prs }}
          if [ "$TOTAL_MERGEABLE" -gt "$MAX_PRS" ]; then
            echo "‚ö†Ô∏è Limiting to first $MAX_PRS PRs (out of $TOTAL_MERGEABLE mergeable)"
            FINAL_PRS=$(echo "$MERGEABLE_PRS" | jq ".[0:$MAX_PRS]")
          else
            FINAL_PRS="$MERGEABLE_PRS"
            echo "‚úÖ Processing all $TOTAL_MERGEABLE discovered PRs (within $MAX_PRS limit)"
          fi

          # Output discovered PRs with detailed validation
          echo "üìä Final PR selection for orchestration:"
          echo "$FINAL_PRS" | jq -r '.[] | "  PR #\(.number): \(.title) (Branch: \(.headRefName))"'
          
          # Enhanced validation for 8-PR scenario
          if [ $(echo "$FINAL_PRS" | jq length) -ge 8 ]; then
            echo "‚úÖ Successfully discovered 8+ PRs for merge orchestration"
          elif [ $(echo "$FINAL_PRS" | jq length) -gt 0 ]; then
            echo "‚ÑπÔ∏è Discovered $(echo "$FINAL_PRS" | jq length) PRs (less than 8-PR test scenario)"
          fi
          
          # Display PR details for validation
          echo "üìã PR Labels and Mergeable Status:"
          echo "$FINAL_PRS" | jq -r '.[] | "  PR #\(.number) [\(.mergeable)]: \(.labels | map(.name) | join(", "))"'

          # Save results with random delimiter
          EOF_DISCOVERED_PRS=$(dd if=/dev/urandom bs=15 count=1 status=none | base64)
          echo "discovered_prs<<$EOF_DISCOVERED_PRS" >> $GITHUB_OUTPUT
          echo "$FINAL_PRS" >> $GITHUB_OUTPUT
          echo "$EOF_DISCOVERED_PRS" >> $GITHUB_OUTPUT

          echo "total_prs=$(echo "$FINAL_PRS" | jq length)" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # ========================================
      # Staging Branch Creation & Sequential Merging
      # ========================================

      - name: "Create Staging Branch"
        id: staging-branch
        if: steps.pr-discovery.outputs.total_prs != '0'
        run: |
          echo "üåø Creating staging branch for PR consolidation"

          TIMESTAMP=$(date +%s)
          STAGING_BRANCH="epic/merge-staging-$TIMESTAMP"
          
          echo "üìù Staging branch: $STAGING_BRANCH"
          
          # Create staging branch from current epic branch state
          git checkout -b "$STAGING_BRANCH"
          
          if [ "${{ steps.validate-inputs.outputs.dry_run }}" = "false" ]; then
            git push origin "$STAGING_BRANCH"
            echo "‚úÖ Staging branch created and pushed"
          else
            echo "üîç DRY RUN: Would create staging branch $STAGING_BRANCH"
          fi

          echo "staging_branch=$STAGING_BRANCH" >> $GITHUB_OUTPUT
          echo "staging_created=true" >> $GITHUB_OUTPUT

      - name: "Sequential PR Merging with Conflict Detection"
        id: pr-merging
        if: steps.staging-branch.outputs.staging_created == 'true'
        run: |
          echo "üîÑ Beginning sequential PR merging process"

          STAGING_BRANCH="${{ steps.staging-branch.outputs.staging_branch }}"
          git checkout "$STAGING_BRANCH"

          # Parse discovered PRs
          DISCOVERED_PRS='${{ steps.pr-discovery.outputs.discovered_prs }}'
          TOTAL_PRS=$(echo "$DISCOVERED_PRS" | jq length)
          
          echo "üìä Processing $TOTAL_PRS PRs for merging"

          SUCCESSFUL_MERGES=()
          FAILED_MERGES=()
          CONFLICT_BRANCHES=()

          # Process each PR sequentially
          for i in $(seq 0 $((TOTAL_PRS - 1))); do
            PR_DATA=$(echo "$DISCOVERED_PRS" | jq -r ".[$i]")
            PR_NUMBER=$(echo "$PR_DATA" | jq -r '.number')
            PR_BRANCH=$(echo "$PR_DATA" | jq -r '.headRefName')
            PR_TITLE=$(echo "$PR_DATA" | jq -r '.title')

            echo ""
            echo "üîÑ Processing PR #$PR_NUMBER: $PR_TITLE"
            echo "   Branch: $PR_BRANCH"

            if [ "${{ steps.validate-inputs.outputs.dry_run }}" = "true" ]; then
              echo "üîç DRY RUN: Would attempt to merge PR #$PR_NUMBER"
              SUCCESSFUL_MERGES+=("$PR_NUMBER")
              continue
            fi

            # Fetch the PR branch
            git fetch origin "$PR_BRANCH"

            # Attempt merge
            if git merge "origin/$PR_BRANCH" --no-edit; then
              echo "‚úÖ Successfully merged PR #$PR_NUMBER"
              SUCCESSFUL_MERGES+=("$PR_NUMBER")
            else
              echo "‚ö†Ô∏è Merge conflicts detected for PR #$PR_NUMBER"
              
              # Create recovery branch for this conflict
              CONFLICT_BRANCH="epic/conflict-pr-$PR_NUMBER-$TIMESTAMP"
              
              # Abort current merge
              git merge --abort
              
              # Create conflict branch from current staging state
              git checkout -b "$CONFLICT_BRANCH"
              git push origin "$CONFLICT_BRANCH"
              
              CONFLICT_BRANCHES+=("$CONFLICT_BRANCH")
              FAILED_MERGES+=("$PR_NUMBER")
              
              echo "üõ°Ô∏è Created conflict branch: $CONFLICT_BRANCH"
              
              # Return to staging branch
              git checkout "$STAGING_BRANCH"
            fi
          done

          # Report results
          echo ""
          echo "üìä Merging Results Summary:"
          echo "   Successful: ${#SUCCESSFUL_MERGES[@]} PRs"
          echo "   Failed: ${#FAILED_MERGES[@]} PRs"
          
          if [ ${#SUCCESSFUL_MERGES[@]} -gt 0 ]; then
            printf '   Successfully merged: %s\n' "${SUCCESSFUL_MERGES[@]}"
          fi
          
          if [ ${#FAILED_MERGES[@]} -gt 0 ]; then
            printf '   Failed merges: %s\n' "${FAILED_MERGES[@]}"
            printf '   Conflict branches: %s\n' "${CONFLICT_BRANCHES[@]}"
          fi

          # Save results
          printf -v SUCCESSFUL_JSON '%s,' "${SUCCESSFUL_MERGES[@]}"
          echo "successful_merges=[${SUCCESSFUL_JSON%,}]" >> $GITHUB_OUTPUT

          printf -v FAILED_JSON '%s,' "${FAILED_MERGES[@]}"
          echo "failed_merges=[${FAILED_JSON%,}]" >> $GITHUB_OUTPUT

          printf -v CONFLICT_JSON '%s,' "${CONFLICT_BRANCHES[@]}"
          echo "conflict_branches=[${CONFLICT_JSON%,}]" >> $GITHUB_OUTPUT

          echo "successful_count=${#SUCCESSFUL_MERGES[@]}" >> $GITHUB_OUTPUT
          echo "failed_count=${#FAILED_MERGES[@]}" >> $GITHUB_OUTPUT

      # ========================================
      # AI Conflict Resolution
      # ========================================

      - name: "Load Merge Orchestrator AI Prompt"
        if: steps.pr-merging.outputs.failed_count != '0' && steps.validate-inputs.outputs.dry_run == 'false'
        id: load-ai-prompt
        run: |
          echo "ü§ñ Loading AI conflict resolution prompt"

          # Prepare conflict context
          FAILED_MERGES='${{ steps.pr-merging.outputs.failed_merges }}'
          CONFLICT_BRANCHES='${{ steps.pr-merging.outputs.conflict_branches }}'
          STAGING_BRANCH="${{ steps.staging-branch.outputs.staging_branch }}"

          PROMPT_DELIMITER=$(dd if=/dev/urandom bs=15 count=1 status=none | base64)
          echo "ai_prompt<<$PROMPT_DELIMITER" >> $GITHUB_OUTPUT

          # Load prompt template (placeholder for actual prompt file)
          # NOTE: This uses a placeholder path - the actual prompt will be created by PromptEngineer
          if [ -f ".github/prompts/coverage-epic-merge-orchestrator.md" ]; then
            cat .github/prompts/coverage-epic-merge-orchestrator.md | sed \
              -e "s/{{STAGING_BRANCH}}/$STAGING_BRANCH/g" \
              -e "s/{{EPIC_BRANCH}}/$EPIC_BRANCH/g" \
              -e "s/{{FAILED_MERGES}}/$FAILED_MERGES/g" \
              -e "s/{{CONFLICT_BRANCHES}}/$CONFLICT_BRANCHES/g" \
              -e "s/{{EPIC_ISSUE_ID}}/$EPIC_ISSUE_ID/g" >> $GITHUB_OUTPUT
          else
            # Fallback prompt if template doesn't exist yet
            echo "# Coverage Epic Merge Orchestrator AI Conflict Resolution" >> $GITHUB_OUTPUT
            echo "" >> $GITHUB_OUTPUT
            echo "You are the Coverage Epic Merge Orchestrator AI assistant." >> $GITHUB_OUTPUT
            echo "" >> $GITHUB_OUTPUT
            echo "## Context" >> $GITHUB_OUTPUT
            echo "- Epic Branch: $EPIC_BRANCH" >> $GITHUB_OUTPUT
            echo "- Staging Branch: $STAGING_BRANCH" >> $GITHUB_OUTPUT
            echo "- Failed Merges: $FAILED_MERGES" >> $GITHUB_OUTPUT
            echo "- Conflict Branches: $CONFLICT_BRANCHES" >> $GITHUB_OUTPUT
            echo "" >> $GITHUB_OUTPUT
            echo "## Task" >> $GITHUB_OUTPUT
            echo "Analyze the merge conflicts in the conflict branches and provide resolution strategies." >> $GITHUB_OUTPUT
            echo "Focus on Coverage Epic PR conflicts and maintain test coverage improvements." >> $GITHUB_OUTPUT
            echo "Create a consolidated merge that preserves all coverage improvements." >> $GITHUB_OUTPUT
          fi

          echo "$PROMPT_DELIMITER" >> $GITHUB_OUTPUT

      - name: "Execute AI Conflict Resolution"
        if: steps.load-ai-prompt.outputs.ai_prompt != '' && steps.validate-inputs.outputs.dry_run == 'false'
        id: ai-resolution
        uses: anthropics/claude-code-action@v1
        continue-on-error: true
        with:
          prompt: ${{ steps.load-ai-prompt.outputs.ai_prompt }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          github_token: ${{ secrets.GITHUB_TOKEN }}
          claude_args: |
            --allowedTools "WebSearch,WebFetch,mcp__github_inline_comment__create_inline_comment,mcp__github_comment__update_claude_comment,Edit,Read,Write,MultiEdit,Bash(./Scripts/*),Bash(dotnet:*),Bash(ls:*),Bash(grep:*),Bash(find:*),Bash(cat:*),Bash(head:*),Bash(tail:*),Bash(jq:*),Bash(git:*),Bash(gh:*)"

      # ========================================
      # Validation & Testing
      # ========================================

      - name: "Validate Staging Branch"
        id: validation
        if: steps.pr-merging.outputs.successful_count != '0'
        run: |
          echo "üîç Validating staging branch integrity"

          STAGING_BRANCH="${{ steps.staging-branch.outputs.staging_branch }}"
          git checkout "$STAGING_BRANCH"

          if [ "${{ steps.validate-inputs.outputs.dry_run }}" = "true" ]; then
            echo "üîç DRY RUN: Would validate staging branch"
            echo "validation_passed=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Build validation
          echo "üî® Validating build integrity"
          if dotnet build zarichney-api.sln --configuration Release --no-restore; then
            echo "‚úÖ Build validation passed"
            BUILD_VALID=true
          else
            echo "‚ùå Build validation failed"
            BUILD_VALID=false
          fi

          # Test execution validation
          echo "üß™ Running test suite validation"
          if ./Scripts/run-test-suite.sh report summary; then
            echo "‚úÖ Test suite validation passed"
            TESTS_VALID=true
          else
            echo "‚ùå Test suite validation failed"
            TESTS_VALID=false
          fi

          # Overall validation
          if [ "$BUILD_VALID" = true ] && [ "$TESTS_VALID" = true ]; then
            echo "‚úÖ Staging branch validation passed"
            echo "validation_passed=true" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Staging branch validation failed"
            echo "validation_passed=false" >> $GITHUB_OUTPUT
          fi

      # ========================================
      # Consolidation PR Creation
      # ========================================

      - name: "Create Consolidation PR"
        id: consolidation-pr
        if: steps.validation.outputs.validation_passed == 'true' && steps.pr-merging.outputs.successful_count != '0'
        run: |
          echo "üìù Creating consolidation PR from staging to epic branch"

          STAGING_BRANCH="${{ steps.staging-branch.outputs.staging_branch }}"
          SUCCESSFUL_MERGES='${{ steps.pr-merging.outputs.successful_merges }}'
          FAILED_MERGES='${{ steps.pr-merging.outputs.failed_merges }}'
          
          if [ "${{ steps.validate-inputs.outputs.dry_run }}" = "true" ]; then
            echo "üîç DRY RUN: Would create consolidation PR"
            echo "consolidation_pr_created=true" >> $GITHUB_OUTPUT
            echo "consolidation_pr_url=https://github.com/example/pr/123" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Push staging branch changes
          git push origin "$STAGING_BRANCH"

          # Create PR title and body
          TIMESTAMP=$(date -u '+%Y-%m-%d %H:%M:%S UTC')
          PR_TITLE="feat: consolidate coverage epic PRs - automated merge orchestration"

          # Build PR body components
          PR_BODY_HEADER="## ü§ñ Coverage Epic Merge Orchestrator Consolidation"
          PR_BODY_INTRO="This PR was automatically generated by the Coverage Epic Merge Orchestrator to consolidate multiple coverage improvement PRs."
          PR_BODY_SUMMARY="### üìä Consolidation Summary"
          PR_BODY_EXEC="- **Execution Time**: $TIMESTAMP"
          PR_BODY_STAGING="- **Staging Branch**: \`$STAGING_BRANCH\`"
          PR_BODY_SUCCESS="- **Successful Merges**: ${{ steps.pr-merging.outputs.successful_count }} PRs"
          PR_BODY_FAILED="- **Failed Merges**: ${{ steps.pr-merging.outputs.failed_count }} PRs"
          PR_BODY_STRATEGY="- **Merge Strategy**: ${{ steps.validate-inputs.outputs.merge_strategy }}"
          PR_BODY_CONSOLIDATED="### ‚úÖ Successfully Consolidated PRs"
          
          # Combine header sections using printf for proper escaping
          PR_BODY=$(printf '%s\n\n%s\n\n%s\n%s\n%s\n%s\n%s\n%s\n\n%s' \
            "$PR_BODY_HEADER" "$PR_BODY_INTRO" "$PR_BODY_SUMMARY" \
            "$PR_BODY_EXEC" "$PR_BODY_STAGING" "$PR_BODY_SUCCESS" \
            "$PR_BODY_FAILED" "$PR_BODY_STRATEGY" "$PR_BODY_CONSOLIDATED")
          
          # Add successful merges list
          if [ "${{ steps.pr-merging.outputs.successful_count }}" != "0" ]; then
            SUCCESS_LIST=$(echo "$SUCCESSFUL_MERGES" | jq -r '.[] | "- PR #\(.)"' 2>/dev/null || echo "- No successful merges")
            PR_BODY="${PR_BODY}\n${SUCCESS_LIST}"
          else
            PR_BODY="${PR_BODY}\n- No successful merges"
          fi

          # Add failed merges section if needed
          if [ "${{ steps.pr-merging.outputs.failed_count }}" != "0" ]; then
            FAILED_LIST=$(echo "$FAILED_MERGES" | jq -r '.[] | "- PR #\(.)"' 2>/dev/null || echo "- No failed merges")
            CONFLICT_LIST=$(echo '${{ steps.pr-merging.outputs.conflict_branches }}' | jq -r '.[] | "- \(.)"' 2>/dev/null || echo "- No conflict branches")
            
            FAILED_SECTION=$(printf '\n\n### ‚ö†Ô∏è Failed Merges (Require Manual Resolution)\n%s\n\n**Conflict Branches Created:**\n%s' "$FAILED_LIST" "$CONFLICT_LIST")
            PR_BODY="${PR_BODY}${FAILED_SECTION}"
          fi

          # Add final sections
          PR_BODY_VALIDATION="### üß™ Validation Results"
          PR_BODY_BUILD="- ‚úÖ **Build Status**: All builds successful"
          PR_BODY_TESTS="- ‚úÖ **Test Suite**: All tests pass with expected skip patterns"
          PR_BODY_QUALITY="- ‚úÖ **Quality Gates**: Standards compliance maintained"
          PR_BODY_IMPACT="### üìà Epic Progress Impact"
          PR_BODY_CONTRIB="This consolidation contributes to the systematic progression toward 90% backend test coverage by January 2026."
          PR_BODY_FOOTER="üéØ **Epic Progress**: Contributing to Backend Testing Coverage to 90% goal"
          PR_BODY_GENERATED="ü§ñ **Generated by Coverage Epic Merge Orchestrator**"
          PR_BODY_TIMESTAMP="**Execution Time**: $TIMESTAMP"
          
          PR_BODY_FINAL=$(printf '%s\n\n%s\n%s\n%s\n%s\n\n%s\n%s\n\n---\n\n%s\n%s\n%s' "$PR_BODY_VALIDATION" "$PR_BODY_BUILD" "$PR_BODY_TESTS" "$PR_BODY_QUALITY" "$PR_BODY_IMPACT" "$PR_BODY_CONTRIB" "$PR_BODY_FOOTER" "$PR_BODY_GENERATED" "$PR_BODY_TIMESTAMP")
          
          PR_BODY="${PR_BODY}\n\n${PR_BODY_FINAL}"

          # Create consolidation PR
          if gh pr create \
            --base "$EPIC_BRANCH" \
            --title "$PR_TITLE" \
            --body "$PR_BODY" \
            --label "type: coverage,automation: orchestrator,epic: coverage-90"; then
            
            CONSOLIDATION_PR_URL=$(gh pr view --json url --jq .url)
            echo "‚úÖ Consolidation PR created successfully"
            echo "consolidation_pr_created=true" >> $GITHUB_OUTPUT
            echo "consolidation_pr_url=$CONSOLIDATION_PR_URL" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Failed to create consolidation PR"
            echo "consolidation_pr_created=false" >> $GITHUB_OUTPUT
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # ========================================
      # Cleanup & Error Recovery
      # ========================================

      - name: "Cleanup Staging Resources"
        if: always() && steps.staging-branch.outputs.staging_created == 'true'
        run: |
          echo "üßπ Cleaning up staging resources"

          STAGING_BRANCH="${{ steps.staging-branch.outputs.staging_branch }}"

          # Only cleanup on success or if explicitly requested
          if [ "${{ steps.consolidation-pr.outputs.consolidation_pr_created }}" = "true" ] || 
             [ "${{ steps.validate-inputs.outputs.dry_run }}" = "true" ]; then
            
            if [ "${{ steps.validate-inputs.outputs.dry_run }}" = "false" ]; then
              echo "üóëÔ∏è Removing staging branch: $STAGING_BRANCH"
              git checkout $EPIC_BRANCH 2>/dev/null || git checkout develop
              git branch -D "$STAGING_BRANCH" 2>/dev/null || true
              git push origin --delete "$STAGING_BRANCH" 2>/dev/null || true
              echo "‚úÖ Staging branch cleanup completed"
            else
              echo "üîç DRY RUN: Would cleanup staging branch $STAGING_BRANCH"
            fi
          else
            echo "‚ö†Ô∏è Preserving staging branch for manual investigation: $STAGING_BRANCH"
          fi

      - name: "Error Recovery & Audit Trail"
        if: failure()
        run: |
          echo "üö® Merge orchestrator encountered errors - implementing recovery"

          # Create audit trail
          TIMESTAMP=$(date -u '+%Y-%m-%d %H:%M:%S UTC')
          AUDIT_COMMENT=$(printf '%s\n\n%s\n%s\n%s\n\n%s\n%s\n%s\n%s\n%s\n\n%s\n%s\n%s\n%s\n%s\n\n%s\n%s\n%s\n%s\n\n%s' \
            "## üö® Coverage Epic Merge Orchestrator Failure" \
            "**Execution Time**: $TIMESTAMP" \
            "**Error Context**: Workflow failed during automated merge orchestration" \
            "**Epic Branch**: \`$EPIC_BRANCH\`" \
            "### üìä Execution State" \
            "- **PRs Discovered**: ${{ steps.pr-discovery.outputs.total_prs || '0' }}" \
            "- **Staging Branch**: ${{ steps.staging-branch.outputs.staging_branch || 'Not created' }}" \
            "- **Successful Merges**: ${{ steps.pr-merging.outputs.successful_count || '0' }}" \
            "- **Failed Merges**: ${{ steps.pr-merging.outputs.failed_count || '0' }}" \
            "### üîç Recovery Actions Needed" \
            "1. Review workflow logs for specific failure points" \
            "2. Check staging branch state if created: ${{ steps.staging-branch.outputs.staging_branch || 'N/A' }}" \
            "3. Validate conflict branches: ${{ steps.pr-merging.outputs.conflict_branches || '[]' }}" \
            "4. Consider manual PR consolidation if needed" \
            "### üõ°Ô∏è Safety Measures" \
            "- All original PRs remain untouched" \
            "- Epic branch preserved in original state" \
            "- Conflict branches created for complex merges" \
            "**Manual intervention may be required to complete orchestration.**")

          # Post audit comment to epic issue
          if [ -n "${{ secrets.GITHUB_TOKEN }}" ]; then
            echo "$AUDIT_COMMENT" | gh issue comment $EPIC_ISSUE_ID --body-file - || true
            echo "üìù Audit trail posted to Epic Issue #$EPIC_ISSUE_ID"
          fi

      # ========================================
      # Execution Summary
      # ========================================

      - name: "Orchestrator Execution Summary"
        if: always()
        run: |
          echo "=================================================="
          echo "üéØ Coverage Epic Merge Orchestrator Summary"
          echo "=================================================="
          echo "üìÖ Execution Time: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "üîß Mode: ${{ steps.validate-inputs.outputs.dry_run == 'true' && 'DRY RUN' || 'LIVE EXECUTION' }}"
          echo "üåø Epic Branch: $EPIC_BRANCH"
          echo "üåø Staging Branch: ${{ steps.staging-branch.outputs.staging_branch || 'Not created' }}"
          echo "üìä Max PRs Configured: ${{ steps.validate-inputs.outputs.max_prs || 'Unknown' }}"
          echo "üè∑Ô∏è Label Filters: ${{ steps.validate-inputs.outputs.label_filters || 'Unknown' }}"
          echo ""
          echo "üìã Orchestration Results:"
          echo "  PRs Discovered: ${{ steps.pr-discovery.outputs.total_prs || '0' }}"
          echo "  Successful Merges: ${{ steps.pr-merging.outputs.successful_count || '0' }}"
          echo "  Failed Merges: ${{ steps.pr-merging.outputs.failed_count || '0' }}"
          echo "  Validation Passed: ${{ steps.validation.outputs.validation_passed || 'false' }}"
          echo "  Consolidation PR: ${{ steps.consolidation-pr.outputs.consolidation_pr_created || 'false' }}"
          echo ""
          if [ "${{ steps.consolidation-pr.outputs.consolidation_pr_created }}" = "true" ]; then
            echo "üéâ SUCCESS: Coverage Epic merge orchestration completed"
            echo "üîó Consolidation PR: ${{ steps.consolidation-pr.outputs.consolidation_pr_url }}"
            echo "üìà Epic #$EPIC_ISSUE_ID progression continues"
          elif [ "${{ steps.pr-discovery.outputs.total_prs }}" = "0" ]; then
            echo "‚ÑπÔ∏è NO ACTION: No mergeable PRs found for orchestration"
          else
            echo "‚ö†Ô∏è PARTIAL: Some PRs processed but consolidation incomplete"
            echo "üîç Check individual step results and manual intervention requirements"
          fi
          echo "=================================================="