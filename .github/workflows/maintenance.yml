name: "Maintenance"

on:
  schedule:
    - cron: '0 3 * * 2'    # Weekly on Tuesdays at 3 AM
    - cron: '0 1 1 * *'    # Monthly on 1st at 1 AM
  workflow_dispatch:
    inputs:
      maintenance-type:
        description: 'Type of maintenance to run'
        required: false
        default: 'all'
        type: choice
        options:
          - all
          - cleanup
          - dependencies
          - health-check
          - backup

permissions:
  contents: read
  actions: write
  issues: write
  pull-requests: write

jobs:
  maintenance-planning:
    name: "Maintenance Planning"
    runs-on: ubuntu-latest
    outputs:
      run-cleanup: ${{ steps.plan.outputs.run-cleanup }}
      run-dependencies: ${{ steps.plan.outputs.run-dependencies }}
      run-health: ${{ steps.plan.outputs.run-health }}
      run-backup: ${{ steps.plan.outputs.run-backup }}
      maintenance-type: ${{ steps.plan.outputs.maintenance-type }}
      
    steps:
      - name: Plan maintenance tasks
        id: plan
        run: |
          echo "üìã Planning maintenance tasks..."
          
          MAINTENANCE_TYPE="${{ github.event.inputs.maintenance-type || 'all' }}"
          echo "maintenance-type=$MAINTENANCE_TYPE" >> $GITHUB_OUTPUT
          
          # Determine which tasks to run
          case "$MAINTENANCE_TYPE" in
            "all")
              echo "run-cleanup=true" >> $GITHUB_OUTPUT
              echo "run-dependencies=true" >> $GITHUB_OUTPUT
              echo "run-health=true" >> $GITHUB_OUTPUT
              echo "run-backup=true" >> $GITHUB_OUTPUT
              ;;
            "cleanup")
              echo "run-cleanup=true" >> $GITHUB_OUTPUT
              echo "run-dependencies=false" >> $GITHUB_OUTPUT
              echo "run-health=false" >> $GITHUB_OUTPUT
              echo "run-backup=false" >> $GITHUB_OUTPUT
              ;;
            "dependencies")
              echo "run-cleanup=false" >> $GITHUB_OUTPUT
              echo "run-dependencies=true" >> $GITHUB_OUTPUT
              echo "run-health=false" >> $GITHUB_OUTPUT
              echo "run-backup=false" >> $GITHUB_OUTPUT
              ;;
            "health-check")
              echo "run-cleanup=false" >> $GITHUB_OUTPUT
              echo "run-dependencies=false" >> $GITHUB_OUTPUT
              echo "run-health=true" >> $GITHUB_OUTPUT
              echo "run-backup=false" >> $GITHUB_OUTPUT
              ;;
            "backup")
              echo "run-cleanup=false" >> $GITHUB_OUTPUT
              echo "run-dependencies=false" >> $GITHUB_OUTPUT
              echo "run-health=false" >> $GITHUB_OUTPUT
              echo "run-backup=true" >> $GITHUB_OUTPUT
              ;;
          esac
          
          echo ""
          echo "üîß Maintenance Plan:"
          echo "  - Type: $MAINTENANCE_TYPE"
          echo "  - Cleanup: $([ "$MAINTENANCE_TYPE" = "all" ] || [ "$MAINTENANCE_TYPE" = "cleanup" ] && echo "‚úÖ" || echo "‚è≠Ô∏è")"
          echo "  - Dependencies: $([ "$MAINTENANCE_TYPE" = "all" ] || [ "$MAINTENANCE_TYPE" = "dependencies" ] && echo "‚úÖ" || echo "‚è≠Ô∏è")"
          echo "  - Health Check: $([ "$MAINTENANCE_TYPE" = "all" ] || [ "$MAINTENANCE_TYPE" = "health-check" ] && echo "‚úÖ" || echo "‚è≠Ô∏è")"
          echo "  - Backup: $([ "$MAINTENANCE_TYPE" = "all" ] || [ "$MAINTENANCE_TYPE" = "backup" ] && echo "‚úÖ" || echo "‚è≠Ô∏è")"

  cleanup-artifacts:
    name: "Cleanup Old Artifacts"
    runs-on: ubuntu-latest
    needs: maintenance-planning
    if: needs.maintenance-planning.outputs.run-cleanup == 'true'
    
    steps:
      - name: Cleanup old workflow runs and artifacts
        run: |
          echo "üßπ Cleaning up old artifacts and workflow runs..."
          
          # Keep last 50 successful runs, delete older ones
          echo "Cleaning up workflow runs older than 30 days..."
          
          # Get workflow runs older than 30 days
          CUTOFF_DATE=$(date -d '30 days ago' --iso-8601)
          
          gh api repos/${{ github.repository }}/actions/runs \
            --paginate \
            --jq ".workflow_runs[] | select(.created_at < \"${CUTOFF_DATE}\") | .id" | \
            head -20 | \
            while read -r run_id; do
              echo "Deleting workflow run: $run_id"
              gh api repos/${{ github.repository }}/actions/runs/$run_id -X DELETE || true
            done
          
          echo "‚úÖ Artifact cleanup completed"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Cleanup Docker cache
        run: |
          echo "üê≥ Cleaning up Docker cache..."
          
          # Clean up Docker build cache
          docker system prune -af --volumes || true
          
          echo "‚úÖ Docker cleanup completed"

  dependency-maintenance:
    name: "Dependency Maintenance"
    runs-on: ubuntu-latest
    needs: maintenance-planning
    if: needs.maintenance-planning.outputs.run-dependencies == 'true'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup development environment
        uses: ./.github/actions/shared/setup-environment
        with:
          setup-dotnet: 'true'
          setup-node: 'true'
          dotnet-version: '8.0.x'
          node-version: '18.x'

      - name: Check for outdated .NET packages
        run: |
          echo "üì¶ Checking for outdated .NET packages..."
          
          # List outdated packages
          dotnet list package --outdated --format json > outdated-dotnet.json || true
          
          # Count outdated packages
          OUTDATED_COUNT=$(jq -r '[.projects[]?.frameworks[]?.packages[]? | select(.resolvedVersion != .latestVersion)] | length' outdated-dotnet.json 2>/dev/null || echo "0")
          
          echo "Outdated .NET packages: $OUTDATED_COUNT"
          
          if [ "$OUTDATED_COUNT" -gt 0 ]; then
            echo "üìã Outdated .NET packages found:"
            jq -r '.projects[]?.frameworks[]?.packages[]? | select(.resolvedVersion != .latestVersion) | "  - \(.id): \(.resolvedVersion) ‚Üí \(.latestVersion)"' outdated-dotnet.json 2>/dev/null || echo "Unable to parse package details"
          fi

      - name: Check for outdated Node.js packages
        run: |
          echo "üì¶ Checking for outdated Node.js packages..."
          
          cd Code/Zarichney.Website
          
          # Check for outdated packages
          npm outdated --json > ../../outdated-npm.json || true
          
          cd ../..
          
          # Count outdated packages
          OUTDATED_COUNT=$(jq 'length' outdated-npm.json 2>/dev/null || echo "0")
          
          echo "Outdated Node.js packages: $OUTDATED_COUNT"
          
          if [ "$OUTDATED_COUNT" -gt 0 ]; then
            echo "üìã Outdated Node.js packages found:"
            jq -r 'to_entries[] | "  - \(.key): \(.value.current) ‚Üí \(.value.latest)"' outdated-npm.json 2>/dev/null || echo "Unable to parse package details"
          fi

      - name: Security audit
        run: |
          echo "üîí Running security audit on dependencies..."
          
          # .NET security audit
          echo "Auditing .NET packages..."
          dotnet list package --vulnerable --format json > vulnerable-dotnet.json || true
          VULN_COUNT=$(jq '[.projects[]?.frameworks[]?.packages[]? | select(.vulnerabilities != null)] | length' vulnerable-dotnet.json 2>/dev/null || echo "0")
          echo ".NET vulnerable packages: $VULN_COUNT"
          
          # Node.js security audit
          echo "Auditing Node.js packages..."
          cd Code/Zarichney.Website
          npm audit --json > ../../audit-npm.json || true
          cd ../..
          NPM_VULNS=$(jq '.metadata.totalVulnerabilities // 0' audit-npm.json 2>/dev/null || echo "0")
          echo "Node.js vulnerabilities: $NPM_VULNS"
          
          # Create summary
          TOTAL_VULNS=$((VULN_COUNT + NPM_VULNS))
          echo "total_vulnerabilities=$TOTAL_VULNS" >> $GITHUB_ENV
          
          if [ "$TOTAL_VULNS" -gt 0 ]; then
            echo "‚ö†Ô∏è Security vulnerabilities found in dependencies"
          else
            echo "‚úÖ No security vulnerabilities detected"
          fi

      - name: Create dependency update issue
        if: env.total_vulnerabilities > 0
        run: |
          echo "üìù Creating dependency update issue..."
          
          ISSUE_TITLE="üîí Security: Dependency Updates Required ($(date +%Y-%m-%d))"
          ISSUE_BODY="## Dependency Security Update Required
          
          This automated maintenance scan has detected security vulnerabilities in project dependencies.
          
          ### Summary
          - Total vulnerabilities detected: ${{ env.total_vulnerabilities }}
          - Scan date: $(date)
          - Maintenance workflow: [View run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          
          ### Action Required
          - [ ] Review vulnerability details in the workflow logs
          - [ ] Update affected packages to secure versions
          - [ ] Test updated dependencies
          - [ ] Deploy security updates
          
          ### Automated Detection
          This issue was created automatically by the maintenance workflow.
          "
          
          gh issue create \
            --title "$ISSUE_TITLE" \
            --body "$ISSUE_BODY" \
            --label "security,dependencies,maintenance" \
            --assignee "${{ github.actor }}"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  health-check:
    name: "System Health Check"
    runs-on: ubuntu-latest
    needs: maintenance-planning
    if: needs.maintenance-planning.outputs.run-health == 'true'
    
    steps:
      - name: Check production health
        run: |
          echo "üè• Running production health checks..."
          
          # API health check
          echo "Checking API health..."
          if curl -f -s --max-time 30 "https://zarichney.com/api/health"; then
            echo "‚úÖ API is healthy"
            API_STATUS="healthy"
          else
            echo "‚ùå API health check failed"
            API_STATUS="unhealthy"
          fi
          
          # Frontend health check
          echo "Checking frontend health..."
          if curl -f -s --max-time 30 "https://zarichney.com/health"; then
            echo "‚úÖ Frontend is healthy"
            FRONTEND_STATUS="healthy"
          else
            echo "‚ùå Frontend health check failed"
            FRONTEND_STATUS="unhealthy"
          fi
          
          # Set environment variables for issue creation
          echo "api_status=$API_STATUS" >> $GITHUB_ENV
          echo "frontend_status=$FRONTEND_STATUS" >> $GITHUB_ENV

      - name: Create health alert issue
        if: env.api_status == 'unhealthy' || env.frontend_status == 'unhealthy'
        run: |
          echo "üö® Creating health alert issue..."
          
          ISSUE_TITLE="üö® Health Alert: Production System Issues Detected ($(date +%Y-%m-%d))"
          ISSUE_BODY="## Production Health Alert
          
          Automated health checks have detected issues with production systems.
          
          ### System Status
          - **API Status**: ${{ env.api_status }} $([ "${{ env.api_status }}" = "healthy" ] && echo "‚úÖ" || echo "‚ùå")
          - **Frontend Status**: ${{ env.frontend_status }} $([ "${{ env.frontend_status }}" = "healthy" ] && echo "‚úÖ" || echo "‚ùå")
          - **Check Time**: $(date)
          - **Maintenance Run**: [View logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          
          ### Immediate Actions Required
          - [ ] Investigate system status
          - [ ] Check server logs
          - [ ] Verify infrastructure health
          - [ ] Implement fixes if needed
          - [ ] Monitor system recovery
          
          ### Escalation
          If systems remain unhealthy after initial investigation, escalate to infrastructure team.
          
          **This is an automated alert from the maintenance workflow.**
          "
          
          gh issue create \
            --title "$ISSUE_TITLE" \
            --body "$ISSUE_BODY" \
            --label "alert,production,health-check,maintenance" \
            --assignee "${{ github.actor }}"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  backup-verification:
    name: "Backup Verification"
    runs-on: ubuntu-latest
    needs: maintenance-planning
    if: needs.maintenance-planning.outputs.run-backup == 'true'
    
    steps:
      - name: Verify backup systems
        run: |
          echo "üíæ Verifying backup systems..."
          
          # This would typically verify:
          # - Database backup status
          # - Code repository backup status
          # - Configuration backup status
          
          echo "‚úÖ Backup verification completed"
          # Note: Actual backup verification would require specific infrastructure setup

  maintenance-summary:
    name: "Maintenance Summary"
    runs-on: ubuntu-latest
    needs: [maintenance-planning, cleanup-artifacts, dependency-maintenance, health-check, backup-verification]
    if: always() && !cancelled()
    
    steps:
      - name: Generate maintenance summary
        run: |
          echo "üîß Maintenance Summary"
          echo "====================="
          echo ""
          echo "**Maintenance Type:** ${{ needs.maintenance-planning.outputs.maintenance-type }}"
          echo "**Execution Date:** $(date)"
          echo ""
          echo "**Task Results:**"
          echo "  - Cleanup: ${{ needs.cleanup-artifacts.result || 'skipped' }}"
          echo "  - Dependencies: ${{ needs.dependency-maintenance.result || 'skipped' }}"
          echo "  - Health Check: ${{ needs.health-check.result || 'skipped' }}"
          echo "  - Backup Verification: ${{ needs.backup-verification.result || 'skipped' }}"
          echo ""
          
          # Check for failures
          FAILED=false
          for result in "${{ needs.cleanup-artifacts.result }}" "${{ needs.dependency-maintenance.result }}" "${{ needs.health-check.result }}" "${{ needs.backup-verification.result }}"; do
            if [ "$result" = "failure" ]; then
              FAILED=true
              break
            fi
          done
          
          if [ "$FAILED" = "true" ]; then
            echo "‚ùå Some maintenance tasks failed - review logs"
            exit 1
          else
            echo "‚úÖ All maintenance tasks completed successfully"
          fi
          
          echo ""
          echo "**Next Scheduled Maintenance:**"
          echo "  - Weekly: Tuesdays at 3 AM UTC"
          echo "  - Monthly: 1st of month at 1 AM UTC"