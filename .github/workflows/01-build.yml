name: "01 ‚Ä¢ Build & Test"

on:
  push:
    branches: [main]
    paths:
      - 'Code/**'
      - 'Scripts/Pipeline/**'
      - '*.sln'
      - '.github/workflows/**'
      - '.github/actions/shared/**'
  pull_request:
    branches: [main, develop]
    paths:
      - 'Code/**'
      - 'Scripts/Pipeline/**'
      - '*.sln'
      - '.github/workflows/**'
      - '.github/actions/shared/**'
  workflow_dispatch:

env:
  DOTNET_VERSION: '8.0.x'
  NODE_VERSION: '18.x'

permissions:
  id-token: write
  contents: read
  actions: read
  pull-requests: write

jobs:
  path-analysis:
    name: "Analyze Changed Paths"
    runs-on: ubuntu-latest
    outputs:
      backend-changed: ${{ steps.check-paths.outputs.backend-changed }}
      frontend-changed: ${{ steps.check-paths.outputs.frontend-changed }}
      docs-only: ${{ steps.check-paths.outputs.docs-only }}
      changed-files: ${{ steps.check-paths.outputs.changed-files }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check changed paths
        id: check-paths
        uses: ./.github/actions/shared/check-paths
        with:
          base-ref: ${{ github.event_name == 'pull_request' && format('origin/{0}', github.event.pull_request.base.ref) || github.event_name == 'push' && github.ref_name == 'main' && 'HEAD~1' || github.event_name == 'push' && github.ref_name == 'develop' && 'origin/main' || 'origin/main' }}

      - name: Display path analysis
        run: |
          echo "üîç Path Analysis Results:"
          echo "  - Backend changed: ${{ steps.check-paths.outputs.backend-changed }}"
          echo "  - Frontend changed: ${{ steps.check-paths.outputs.frontend-changed }}"
          echo "  - Documentation only: ${{ steps.check-paths.outputs.docs-only }}"
          echo "  - Changed components: ${{ steps.check-paths.outputs.changed-files }}"
          echo "  - Test run: End-to-end validation"

  backend-build:
    name: "Backend ‚Ä¢ Build & Test"
    runs-on: ubuntu-latest
    needs: path-analysis
    if: needs.path-analysis.outputs.backend-changed == 'true'
    timeout-minutes: 30

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup development environment
        uses: ./.github/actions/shared/setup-environment
        with:
          setup-dotnet: 'true'
          setup-node: 'false'
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Execute backend build and test
        run: |
          echo "üöÄ Running backend build and test pipeline..."
          
          # Set CI environment variables
          export CI_ENVIRONMENT=true
          export QUALITY_GATE_ENABLED=true
          export COVERAGE_THRESHOLD=16
          
          # Determine coverage flexibility based on branch/PR context
          COVERAGE_FLAGS=""
          if [[ "${{ github.head_ref }}" == test/* ]] || [[ "${{ github.ref_name }}" == test/* ]]; then
            echo "üß™ Test branch detected - enabling coverage flexibility"
            COVERAGE_FLAGS="--allow-low-coverage"
            export COVERAGE_FLEXIBLE=true
          elif [[ "${{ github.ref_name }}" == "develop" ]] || [[ "${{ github.base_ref }}" == "develop" ]]; then
            echo "üîß Infrastructure validation on develop branch - enabling coverage flexibility"
            COVERAGE_FLAGS="--allow-low-coverage"
            export COVERAGE_FLEXIBLE=true
          elif [[ "${{ github.event_name }}" == "pull_request" ]] && [[ "${{ contains(github.event.pull_request.labels.*.name, 'low-coverage-allowed') }}" == "true" ]]; then
            echo "üè∑Ô∏è low-coverage-allowed label detected - enabling coverage flexibility"
            COVERAGE_FLAGS="--allow-low-coverage"
            export COVERAGE_FLEXIBLE=true
          fi
          
          # Execute the pipeline script (disable parallel for accurate coverage collection)
          ./Scripts/Pipeline/build-backend.sh --threshold 16 $COVERAGE_FLAGS
        
      - name: Upload backend artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: backend-build-${{ github.run_number }}
          path: artifacts/backend/
          retention-days: 7

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ github.run_number }}
          path: |
            TestResults/
            CoverageReport/
          retention-days: 7

      - name: Testing Analysis with Claude AI
        if: always() && github.event_name == 'pull_request'
        id: claude-testing
        uses: grll/claude-code-action@beta
        continue-on-error: true
        with:
          use_oauth: true
          claude_access_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          claude_refresh_token: ${{ secrets.CLAUDE_REFRESH_TOKEN }}
          claude_expires_at: ${{ secrets.CLAUDE_EXPIRES_AT }}
          secrets_admin_pat: ${{ secrets.SECRETS_ADMIN_PAT }}
          direct_prompt: |
            # Testing Analysis for zarichney-api Project

            You are a senior software testing expert and quality assurance specialist conducting a comprehensive testing analysis for this pull request in the zarichney-api project.

            ## Analysis Data

            Please analyze the test results and coverage data which contains:
            - Test execution results (unit and integration tests)
            - Code coverage metrics and trends
            - Test performance and execution times
            - Test failure analysis and patterns
            - Testing best practices adherence

            ## Analysis Framework

            ### 1. Test Coverage Assessment
            - Line coverage percentage and quality
            - Branch coverage analysis
            - Missing test coverage identification
            - Coverage trend analysis (improvement/regression)

            ### 2. Test Quality Analysis
            - Test design patterns and best practices
            - Test naming conventions and clarity
            - Test organization and structure
            - Mock usage and test isolation

            ### 3. Test Performance Review
            - Test execution time analysis
            - Slow test identification
            - Performance regression detection
            - Test parallelization opportunities

            ### 4. Test Failure Analysis
            - Failed test root cause analysis
            - Flaky test identification
            - Test reliability assessment
            - Error pattern recognition

            ### 5. Testing Standards Compliance
            - xUnit best practices adherence
            - Testcontainers usage patterns
            - Test categorization (Unit/Integration)
            - Assertion quality and clarity

            ## Output Requirements

            Provide a comprehensive markdown report with:

            ### Executive Summary
            - Overall test health assessment (Excellent/Good/Fair/Poor/Critical)
            - Key metrics summary (coverage %, pass rate, execution time)
            - Critical issues requiring immediate attention

            ### Detailed Analysis

            #### üß™ Test Coverage Report
            - Current coverage metrics with trend analysis
            - Areas lacking adequate test coverage
            - Recommendations for coverage improvement

            #### ‚ö° Test Performance Analysis
            - Execution time breakdown and performance trends
            - Slow test identification with optimization suggestions
            - Parallelization and efficiency recommendations

            #### üîç Test Quality Assessment
            - Test design pattern evaluation
            - Best practices adherence review
            - Code quality of test implementations

            #### üö® Issues and Risks
            - Critical test failures requiring immediate attention
            - Flaky tests affecting reliability
            - Technical debt in test codebase

            #### üéØ Recommendations
            Prioritized actionable recommendations:
            1. **CRITICAL**: Issues blocking deployment or causing instability
            2. **HIGH**: Important improvements for test reliability
            3. **MEDIUM**: Quality improvements and optimizations
            4. **LOW**: Minor enhancements and best practices

            ### Metrics Dashboard
            - Test pass rate: X%
            - Code coverage: X% (trend: ‚Üë/‚Üì/‚Üí)
            - Average execution time: Xs
            - Number of flaky tests: X
            - Testing debt score: X/100

            ## Context Awareness

            Consider the zarichney-api project context:
            - ASP.NET 8 backend with xUnit testing framework
            - Angular frontend with appropriate testing tools
            - Testcontainers for integration testing
            - Docker-based test environment
            - CI/CD pipeline integration requirements

            ## Tone and Style

            - Professional and constructive
            - Focus on actionable improvements
            - Explain the business impact of testing issues
            - Provide specific, implementable recommendations
            - Balance between thoroughness and clarity

            Please analyze the test results and provide your comprehensive testing analysis.

  frontend-build:
    name: "Frontend ‚Ä¢ Build & Test"
    runs-on: ubuntu-latest
    needs: path-analysis
    if: needs.path-analysis.outputs.frontend-changed == 'true'
    timeout-minutes: 20

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup development environment
        uses: ./.github/actions/shared/setup-environment
        with:
          setup-dotnet: 'false'
          setup-node: 'true'
          node-version: ${{ env.NODE_VERSION }}

      - name: Execute frontend build and test
        run: |
          echo "üöÄ Running frontend build and test pipeline..."
          
          # Set CI environment variables
          export CI_ENVIRONMENT=true
          
          # Execute the pipeline script
          ./Scripts/Pipeline/build-frontend.sh --prod
        
      - name: Upload frontend artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: frontend-build-${{ github.run_number }}
          path: artifacts/frontend/
          retention-days: 7

  build-summary:
    name: "Build Summary"
    runs-on: ubuntu-latest
    needs: [path-analysis, backend-build, frontend-build]
    if: always() && !cancelled()
    
    steps:
      - name: Generate build summary
        run: |
          echo "üìä Build Pipeline Summary"
          echo "========================"
          echo ""
          echo "**Path Analysis:**"
          echo "  - Backend changed: ${{ needs.path-analysis.outputs.backend-changed }}"
          echo "  - Frontend changed: ${{ needs.path-analysis.outputs.frontend-changed }}"
          echo "  - Documentation only: ${{ needs.path-analysis.outputs.docs-only }}"
          echo "  - Components: ${{ needs.path-analysis.outputs.changed-files }}"
          echo ""
          echo "**Build Results:**"
          echo "  - Backend build: ${{ needs.backend-build.result || 'skipped' }}"
          echo "  - Frontend build: ${{ needs.frontend-build.result || 'skipped' }}"
          echo ""
          
          # Check for failures
          if [ "${{ needs.backend-build.result }}" = "failure" ] || [ "${{ needs.frontend-build.result }}" = "failure" ]; then
            echo "‚ùå One or more builds failed"
            exit 1
          elif [ "${{ needs.path-analysis.outputs.docs-only }}" = "true" ]; then
            echo "üìö Only documentation changed - no builds required"
          else
            echo "‚úÖ All required builds completed successfully"
          fi